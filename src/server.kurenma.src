#
# $Id: server.kurenma.src 171 2017-06-09 15:26:27+04:00 toor $"
#
_bashlyk=kurenma . bashlyk
#
#
#
#
kurenma-server::resetCounters() {

  bRevoked=0
  cn=''
  tsStart=0
  tsWait=60

}
#
kurenma-server::closeConnection() {

  err::debug 3 "client $cn - exchange completed"

  kurenma-server::resetCounters

  echo "exchange completed"
  sleep 1
  echo "q"

}
#
kurenma-server::revoked() {

  err::debug 3 "client $cn cert revoked"
  echo "client cert revoked"

  kurenma-server::closeConnection

}
#
kurenma-server::limitConnectionTime() {

  std::isNumber $1       || on error return NotNumber "first argument"
  std::isNumber $tsStart || on error return NotNumber "$tsStart"

  (( tsStart > 0 )) || return 0
  [[ $cn ]] || on error return EmptyArgument "cn"

  local i=$(( $( exec -c date "+%s" ) - $tsStart ))

  (( i > 16 )) && err::debug 3 "client $cn - exchange time is ${i}sec"

  if (( $i > $1 )); then

    err::debug 3 "client $cn - exchange down by timeout ${i}sec"
    echo "client $cn - exchange down by timeout"

    kurenma-server::closeConnection

  fi

}
#
kurenma-server::waitRequest() {

  local bIssuer='false' bRevoked=0 cn rc s tsStart=0 tsWait=60

  while true; do

    read -t $tsWait s
    rc=$?

    if   (( rc > 128 )); then

      (( bRevoked > 0 )) && kurenma-server::revoked

      if (( tsStart == 0 )); then

        err::debug 3 "wait ${tsWait}sec"
        tsWait=$(( tsWait + 10 ))

      fi

    elif (( rc > 0 )); then

      err::debug 3 "input closed"
      break

    elif [[ $s =~ ^signalStop$ ]]; then

      err::debug 3 "SSL server down"

      echo Q
      sleep 0.2
      break

    elif [[ $s =~ ^verify.*revoked.* ]]; then

      err::debug 3 "warn: $cn revoked certificate"
      bRevoked=1
      tsWait=2

    elif [[ $s =~ depth=0.*CN.* ]]; then

      rc="${s/depth=0/subject:}"
      s="${s##*, CN = }"
      s="${s%,*}"

      [[ "$s" == "$cn" ]] && continue || cn=$s

      err::debug 3 "client $cn - exchange started"
      err::debug 3 "SSL: $rc"
      rc=0

      tsStart=$(date "+%s")
      tsWait=4

    elif [[ $bIssuer == 'false' && $s =~ depth=1.*CN.* ]]; then

      err::debug 3 "SSL: ${s/depth=1/ issuer:}"
      bIssuer='true'

    elif [[ $s =~ client-data.* ]]; then

      if (( bRevoked > 0 )); then

        err::debug 3 "client data ignored"

      else

        s=${s##*client-data}
        err::debug 5 "client data: ${s:1:10}<skip>"
        kurenma-server::handleRequest $cn ${s:1:45}

        sleep 0.1
        kurenma-server::closeConnection

      fi

    elif [[ $s =~ ^(CIPHER|ERROR|ACCEPT) ]];
    then

      err::debug 3 "SSL: $s"

    fi

    kurenma-server::limitConnectionTime 32

  done

}
#
kurenma-server::handleRequest() {

  throw on MissingArgument "$1" "$2"

  throw on EmptyVariable dev pathDat pathIni pool tsKeepalive tsPeerTimeout server

  local aCIDR cmdWG cnClient fmt fn fnLeased i ip ipClient peer s

  cnClient=$1
  peer=$2
  fmt="\n%s - prepare tunnel settings (client public key=%s) on %s:\n"

  fnLeased=${pathDat}/${cn}.${dev}.leased

  err::debug 4 && printf -- "$fmt" "$cnClient" "${peer:0:10}<skip>" "$dev" >&2

  if [[ $(wg show $dev | grep peer | wc -l) -ge 253 ]]; then

    wg set $dev peer $(                                                        \
                                                                               \
      wg show $dev latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1  \
                                                                               \
    ) remove

  fi

  for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

    if std::isNumber ${s##*:}; then

      #ignore too low timestamps
      (( ${s##*:} < 1800 )) && continue

      i=$(( $(date +%s) - ${s##*:} ))

      if (( i >= tsPeerTimeout )); then

        wg set $dev peer ${s%%:*} remove
        err::debug 2 \
          "peer ${s:0:10}<skip> is removed due to inactivity over an ${i}s.. $?"

      fi

    else

      on error warn InvalidArgument "${s##*:}"

    fi

  done

  if [[ "$pool" == "commonname" ]]; then

    ## TODO IP must be in the server network - checking required
    s="$cnClient - lease of the IP by Common Name"
    if ipClient=$( net::ipv4.host $cnClient ); then
      err::debug 3 "$s - $ipClient"
    else
      err::debug 3 "$s - not resolved.."
    fi

  fi

  if [[ ! $ipClient || $pool == "dynamic" ]]; then

    [[ -f $fnLeased ]] || touch $fnLeased

    ipClient=$(                                                                \
                                                                               \
      grep -P "^${cnClient}:\S+$" $fnLeased |tail -n 1| cut -f 2 -d':'|xargs   \
                                                                               \
    )

    ipClient=$( net::ipv4.host $ipClient )
    s="$cnClient - lease of the already used IP"
    err::debug 3 "$s - $ipClient"

  fi

  if [[ ${server%/*} == $ipClient ]]; then

    on error warn InvalidArgument "the IP address $ipClient is already in use, skipped"

    unset ipClient

  fi

  if [[ ! $ipClient ]]; then

    ipClient=$(( ${server%/*} ))
    s="$( wg show $dev allowed-ips )"
    ## TODO ip range for pool
    for ((i=$(( ${ipClient##*.} + 1 )); i<=254; i++)); do

      ip="${ipClient%.*}.$i";

      if [[ $s =~ ${ip}/32 ]]; then

        continue

      else

        ipClient=$( net::ipv4.host $ip )
        s="$cnClient - lease of the dynamic IP"
        err::debug 3 "$s - $ipClient"
        break

      fi

    done

  fi

  if [[ ! $ipClient || ${server%/*} == $ipClient ]]; then

    echo "not allocated IP to the client"
    on error echo+return InvalidArgument "not allocated IP to the client"

  fi

  aCIDR=$( net::ipv4.cidr ${ipClient}/32 ${aIpsAllowed[@]} )

  err::debug 3 "$cnClient - allowed ips - $aCIDR"

  std::temp fn

  cmdWG="$(                                                                    \
                                                                               \
    printf -- 'wg set %s peer %s allowed-ips %s persistent-keepalive %d'       \
              "$dev" "$peer" "${aCIDR// /,}" "$tsKeepalive"                    \
                                                                               \
  )"

  if $cmdWG 2>$fn; then

    printf -- 'OK:%s:%s:%s:%s\n'                                               \
              "$( wg show $dev private-key | wg pubkey )"                      \
              "$( wg show $dev listen-port )"                                  \
              "${ipClient}"                                                    \
              "${server%/*}"

    for s in $( wg show $dev peers ); do

      grep ":${s:0:10}$" $fnLeased

    done > $fn

    mv -f $fn $fnLeased
    echo "${cnClient}:${ipClient}:$(date +%s):${peer:0:10}" >> $fnLeased

  else

    echo "Error $(< $fn) $?"
    rm -f $fn

  fi

  for s in $( wg show $dev allowed-ips | grep none | cut -f 1 | xargs ); do

    wg set $dev peer $s remove
    err::debug 3 "${dev}: peer ${s:0:10}<skip> is removed as unused .. $?"

  done

  err::debug 1 "server configuration updated."

  wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
  chmod 0600 ${pathIni}/${cn}.${dev}.conf

}
#
kurenma-server::setupTunnel() {

  throw on EmptyVariable dev server port

  err::debug 3 && printf -- "Init WireGuard device %s" "$dev"

  try {

    ip link del dev $dev 2>/dev/null || true
    ip link add dev $dev type wireguard
    ip address add $server dev $dev
    wg set $dev private-key <(wg genkey) listen-port $port
    ip link set up dev $dev

  } catch {

    ERR::exception.message
    exit $?

  }

  err::debug 3 "init new server pub key: \
    $( wg show $dev private-key | wg pubkey | head -c 10 )<skip>"

  return 0

}
#
# exported function
#
kurenma-daemon::service() {

  DEBUGLEVEL=5

  [[ $UID == 0 ]] || on error warn+exit NotPermitted "You must be root to run this."

  exit+warn on CommandNotFound cut kill ps sort

  throw on EmptyVariable cn dev fnCrt fnKey pathCA pathCrt pathKey port        \
                         portAuth server

  local cmdSSL fn fnDH

  if [[ ! ( $( wg|grep $dev ) && $( ip addr show $dev|grep ${server%/*} ) ) ]];
  then

    kurenma-server::setupTunnel

  fi

  fnDH=${pathCrt}/dh2048.pem

  cmdSSL="                                                                     \
    openssl s_server -cert $fnCrt -key $fnKey -accept $portAuth                \
      -CApath $pathCA -Verify 2 -crl_check_all -dhparam $fnDH                  \
  "

  pid::stop $cmdSSL

  while true; do

    err::debug 3 "Daemon for WireGuard clients (re)started.."

    std::temp fn type=pipe

    export _kurenma_control_channel=$fn

    kurenma-server::waitRequest < $fn | $cmdSSL > $fn 2>&1 &

    pid::onExit.stop $!

    wait $!
    rm -f $fn

    kurenma-daemon::waitSignal 0.2 || break

  done

}
#
#
#
