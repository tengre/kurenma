#
# $Id: client.kurenma.src 157 2017-03-06 16:10:03+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
#
udmResetCounters() {

  bRevoked=0
  cn=''
  tsStart=0
  tsWait=60

}
#
udmCloseConnection() {

  udfDebug 3 "server $cn - exchange completed"

  udmResetCounters

  sleep 1
  udfStopProcess $cmdSSL

}
#
udmRevoked() {

  udfDebug 3 "my $cn cert revoked"
  udmCloseConnection

}
#
#
udmLimitConnectionTime() {

  udfIsNumber $1 || eval $( udfOnError retwarn NotNumber "$1" )
  udfIsNumber $tsStart || eval $( udfOnError retwarn NotNumber "$tsStart" )

  (( tsStart > 0 )) || return 0
  [[ $cn ]] || eval $( udfOnError retwarn EmptyArgument "server cn" )

  local i=$(( $(date "+%s") - $tsStart ))

  (( i > 16 )) && udfDebug 3 "server $cn - exchange time is ${i}sec"

  if (( $i > $1 )); then

    udfDebug 3 "server $cn - exchange down by timeout ${i}sec"
    udmCloseConnection

  fi

}
#
udfWaitResponse() {

  local bRevoked=0 cn rc s tsStart=0 tsWait=60

  echo "client-data $sPub"
  tsStart=$(date "+%s")

  while true; do

    read -t $tsWait s
    rc=$?

    if   (( rc > 128 )); then

      (( bRevoked > 0 )) && udmRevoked

    elif (( rc > 0 )); then

      udfDebug 3 "input closed"
      udmCloseConnection
      sleep 0.2
      break

    elif [[ $s =~ ^signalStop$ ]]; then

      udfDebug 3 "SSL client down"

      udmCloseConnection
      sleep 0.2
      break

    elif [[ $s =~ ^client.cert.revoked ]]; then

      udfDebug 3 "warn: $cn revoked certificate"
      bRevoked=1
      tsWait=2

    elif [[ $s =~ depth=0.*CN.* ]]; then

      s="${s##*, CN = }"
      s="${s%,*}"

      [[ "$s" == "$cn" ]] && continue || cn=$s

      udfDebug 3 "server $cn - exchange started"

      tsStart=$(date "+%s")
      tsWait=4

    elif [[ $s =~ ^OK:.* ]]; then

        udfDebug 3 "server data: ${s:1:32}<skip>"
        sleep 1.1
        udmCloseConnection
        ## TODO
        #udfSetupTunnel ${s//:/ } $sKey

    elif [[ $s =~ ^(verify|CIPHER|ERROR|CONNECTION|ACCEPT|subject|issuer) ]];
    then

      udfDebug 3 "SSL: $s"

    fi

    udmLimitConnectionTime 32

  done

}
#
udfKnocking() {

  udfThrowOnEmptyVariable fnCA host portAuth

  local i s

  i=256

  s=$(                                                                         \
                                                                               \
    openssl x509 -sha1 -in $fnCA -noout -fingerprint | sed -r -e               \
    "s/^SHA1 Fing.*nt=(..):(..):(..):(..):(..):(..):.*$/0x\1\2 0x\3\4 0x\5\6/" \
                                                                               \
  )

  [[ -n "$s" ]] || eval $(                                                     \
                                                                               \
    udfOnError throw EmptyResult "$fnCA - not valid format"                    \
                                                                               \
  )

  udfDebug 5 "CA cert fingerprint header: $s"

  s=$( printf -- "%d %d %d" $s ) || eval $(                                    \
                                                                               \
    udfOnError throw InvalidArgument "$fnCA - hexadecimal data expected"       \
                                                                               \
  )

  udfDebug 5 "knock ports sequence: $s"

  udfDebug 2 "check server $host availibity:"

  while true; do

    nc -w 3 -z ${host} ${portAuth} 2>/dev/null && break
    udfDebug 2 && echo -n "."

    if ! (( i % 8 )); then

      knock $host $s
      udfDebug 2 && echo -n "!"

    fi

    if ! udfWaitSignal 1; then

      echo "x"
      return $(_ iErrorAbortedBySignal)

    fi

    i=$((i-1))

    ! (( i % 32 )) && echo ""

    if (( $i <= 0 )); then

      echo "fail after 256 attempts.. try again"
      eval $( udfOnError warn NotAvailable "${host}:${portAuth}" )
      i=256

    fi

  done >&2

  return 0

}
#
udfGetTunnelSettings() {

  udfThrowOnEmptyVariable cmdSSL cn fnKey host portAuth

  local fmt fnAns sKey sPub s

  fmt="\nclient WireGuard keys:\nprivate - %s<skip>\npublic  - %s<skip>\n"

  s="$(_ iErrorAbortedBySignal) stop signal received"

  udfMakeTemp fnAns

  while true; do

    udfKnocking || break

    udfDebug 2 "ok."

    udfWaitSignal 4 || break

    sKey=$( wg genkey )
    sPub=$( echo $sKey | wg pubkey )

    ( sleep 6 && udfStopProcess $cmdSSL ) &

    s="$(                                                                      \
      echo "client-data $sPub" | $cmdSSL | tr -d '\r' | tee $fnAns             \
        | grep '^OK:'                                                          \
    )"

    #udfMakeTemp fn type=pipe
    #export _kurenma_control_channel=$fn
    #udfWatchResponse < $fn | $cmdSSL > $fn 2>&1 &

    udfDebug 3 && printf -- $fmt "${sKey:0:10}" "${sPub:0:10}"

    [[ $s =~ ^OK: ]] && break

    [[ $s ]] || s="$(< $fnAns)"

    eval $(                                                                    \
                                                                               \
      udfOnError warn InvalidArgument                                          \
        "malformed answer from ${host}:${portAuth} $s"                         \
                                                                               \
    )

    s="$(_ iErrorAbortedBySignal ) stop signal received"
    udfWaitSignal 8 || break

  done >&2

  rm -f $fnAns

  echo "${s//:/ } $sKey"

  return 0
}
#
udfSetupTunnel() {

  udfThrowOnEmptyVariable dev host

  local ipClient ipServer peer port sKey

  [[ $1 == $(_ iErrorAbortedBySignal) ]] && return $(_ iErrorAbortedBySignal)

  [[ $1 != "OK" ]] && return $( _ iErrorInvalidArgument )

  shift

  peer=$( echo $1 | grep -P "^[a-zA-Z0-9+/]+={0,2}$" )
  udfIsNumber $2 && port=$2 || port=''
  ipClient=$( udfGetValidIPsOnly $3 )
  ipServer=$( udfGetValidIPsOnly $4 )
  sKey=$5

  udfDebug 3 && printf -- $fmtCon "$host" "$port" "${peer:0:10}<skip>"    \
    "$ipClient" "$ipServer"

  udfThrowOnEmptyVariable peer port ipClient ipServer

  udfDebug 0 && printf -- "\nSetup tunnel for peer %s<skip>: " "${peer:0:10}"

  try {

    ip link del dev $dev || true
    ip link add dev $dev type wireguard

    wg set $dev private-key <( echo $sKey ) \
      peer $peer \
      allowed-ips 0.0.0.0/0 \
      persistent-keepalive $tsKeepalive \
      endpoint "${host}:${port}"

    ip address add "${ipClient}"/24 dev $dev
    ip link set up dev $dev

   } catch {

      ERR::exception.message
      exit $?

   }

  return 0

}
#
udfSetDefaultRoute() {

  udfThrowOnEmptyVariable dev _peIPv4

  local s

  s="$( wg show $dev endpoints | sed -re 's/.*\t(.*):.*/\1/' )"
  udfDebug 4 "server endpoint: $s"

  s="$( ip route get $s | grep -Po "$_peIPv4 via $_peIPv4" )"
  udfDebug 4 "route rule for server: $s"

  if [[ -n "$s" ]]; then

  try {

      ip route add $s || true
      ip route add 0/1 dev $dev
      ip route add 128/1 dev $dev

   } catch {

      ERR::exception.message
      exit $?

   }

    udfDebug 2 "tunnel $dev used as default route ($s)"

  else

    eval $( udfOnError throw EmptyOrMissingArgument "default route fail" )

  fi

  return 0

}
#
udfService() {

  udfThrowOnCommandNotFound false knock ping tee true
  udfThrowOnEmptyVariable bDefaultRoute cn dev host fnCA fnCrt fnKey pathIni   \
    portAuth tsPeerTimeout

  local bStart cmdSSL fmtCon fmtSSL s

  fmtSSL="SSL auth info:\nClient Common Name - %s\n"
  fmtCon="Connection properties from %s:\nremote port: %d\nserver  key:        \
    %s\ntunnel  IPs: leased/remote - %s/%s\n"

  cmdSSL="                                                                     \
    openssl s_client -connect ${host}:${portAuth} -CAfile $fnCA -cert $fnCrt   \
      -key $fnKey -verify 1 -quiet                                             \
  "

  for s in "$fnCrt" "$fnKey" "$fnCA"; do

    [[ -f $s ]] || eval $( udfOnError exitecho NoSuchFileOrDir "$s" )

    if ! grep -P '^-----(BEGIN|END)' $s >/dev/null 2>&1; then

      eval $( udfOnError exitecho InvalidArgument "$s - bad format" )

    fi

  done

  [[ $bDefaultRoute =~ ^(false|true)$ ]] || bDefaultRoute=false

  udfDebug 3 && printf -- "$fmtSSL" "$cn"

  bStart=true

  while true; do

    if $bStart; then

      ## TODO try first use saved wg config
      ## TODO bad error handling

      udfSetupTunnel $( udfGetTunnelSettings ) || {

        eval $( udfOnError warn $? "setup tunnel settings" )
        break

      }

      $bDefaultRoute && udfSetDefaultRoute
      udfDebug 1 && printf -- "\nclient configuration done.\n"
      udfDebug 5 && udfShowPeerInfo

      wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
      chmod 0600 ${pathIni}/${cn}.${dev}.conf

      ping -q -W 1 -Ñ 3 $ipServer >/dev/null 2>&1

    fi

    udfDebug 2 "check connection every $tsPeerTimeout sec.."
    udfWaitSignal $tsPeerTimeout || break

    for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

      if udfIsNumber ${s##*:}; then

        if (( $(date +%s) - ${s##*:} >= tsPeerTimeout )); then

          wg set $dev peer ${s%%:*} remove
          udfDebug 3 "peer ${s:0:10}<skip> removed .. $?"
          bStart=true

        else

          bStart=false

        fi

      else

        eval $( udfOnError warn InvalidArgument "${s##*:}" )

      fi

    done

  done

}
#
#
#
