#!/bin/bash
#
# $Id: kurenmad 133 2017-02-02 17:16:54+04:00 toor $"
#
_bashlyk=kurenma . bashlyk
#
#
#
_kurenma_sVersion=0.7
_kurenma_pathLib=/usr/share/kurenma
_kurenma_sSignal=none
#
#
#
#****h* kurenma/.
#
#  DESCRIPTION
#
#    kurenma  is a package that includes tools for configuration and control
#    WireGuard tunnels.
#
#  COMMANDS
#
#    kurenmactl
#        management tool for kurenmad(8) daemon
#
#    kurenmad
#        daemon for automatic configuration and control of the WireGuard tunnels
#
#    gen-ssl-kurenma
#        generate   CA   infrastructure   based   on   OpenSSL   and   x.509
#        certificate/key pair for client and server peers
#
#    setup-knockd
#        get   knock-sequence   of   port   numbers   from   the    server's
#        X.509-certificate and write the appropriate section of the settings
#        in the knockd.conf(5) configuration file. Only required for  server
#        roles
#
#    update-firehol
#        adds  the  IP-address to the white list of the firehol(1) firewall.
#        It's designed to run from the service knockd(1) to allow  WireGuard
#        client access
#
#  SEE ALSO
#       kurenmactl(8), kurenmad(8), kurenma.ini(5), gen-ssl-kurenma(8),
#       update-firehol(8), setup-knockd(8), firehol(1), knockd(1), knockd.conf(5)
#******
#****h* kurenma/command
#  DESCRIPTION
#
#    This section described commands of package
#
#******
#****h* kurenma/configuration
#  DESCRIPTION
#
#    This section described configurations of package
#
#******
#****h* command/kurenmad
#
#  USAGE
#
#    kurenmad
#
#  DESCRIPTION
#
#    kurenmad - daemon for automatic configuration and control of the WireGuard
#    tunnels.
#    Depending on the role, kurenmad acts as a server that receives requests
#    to  create  WireGuard  tunnel or as a client requesting the creation of
#    such a tunnel. For key exchanging used X.509 certificates.
#
#  SEE ALSO
#
#    kurenma(7), kurenmactl(8), kurenma.ini(5)
#
#******
udfWaitSignal() {

	if [[ $_kurenma_sSignal == "stop" ]]; then

		udfDebug 4 "Stop signal received before waiting"
		return $(_ iErrorAbortedBySignal)

	fi

	[[ $1 =~ ^[0-9]+(\.[0-9]+)?$ ]] || eval $( udfOnError return InvalidArgument "$1" )

	sleep $1 &
	wait $!

	if [[ $_kurenma_sSignal == "stop" ]]; then

		udfDebug 4 "Stop signal received after waiting"
		return $(_ iErrorAbortedBySignal)

	fi

	return 0
}
#
udfShowPeerInfo() {

	udfThrowOnEmptyVariable dev

	printf -- "\n\nWireGuard interface %s info:\n-----------------------------\n\n" "$dev"

	wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

	ip addr show $dev | grep inet

	printf -- "\n----\n"

}
#
udfSignal() {

	[[ -n "$_kurenma_control_channel" && -p "$_kurenma_control_channel" ]] && echo "signalStop" > $_kurenma_control_channel

	_kurenma_sSignal='stop'

	udfStopProcess childs sleep

	udfFinally "service down initiated by signal,"

	sleep 1.8
	#udfOnTrap

}
#
udfMain() {

  DEBUGLEVEL=5

  udfThrowOnCommandNotFound echo grep ip mkdir nc openssl sed sleep tail wg

  [[ $UID == 0 ]] || eval $( udfOnError throw NotPermitted "You must be root to run this." )

  local -a aId
  local ini fnCA fnCrt fnKey pathCA pathCrt pathDat pathIni pathKey pathRun s
  local bDefaultRoute pool port portAuth role tsKeepalive tsPeerTimeout
  local aReqOptByRole ca cn dh dev host server

  udfExitIfAlreadyStarted

  pathDat=$( _ pathDat )
  pathIni=$( _ pathIni )
  pathRun=$( _ pathRun )

  pathCA=${pathIni}/ssl/certs
  pathCrt=${pathIni}/ssl/public
  pathKey=${pathIni}/ssl/private
  ini=${pathIni}/kurenma.ini

  mkdir -p $pathDat || eval $( udfOnError retecho NotExistNotCreated $pathDat )

  INI ini
  ini.load $ini                                                                \
              []role,tunnel.name,server,port,tunnel.cidr,pool.method,          \
                ts.keepalive,ts.timeout.peer,route.default                    :\
                                                                               \
           [ssl]ca,cn,dh,port                                                 :\
                                                                               \
    [ips.allowed]=                                                             \
  :

  role=$( ini.get role )

  case $role in

  client)

             host=$( ini.get server )
    bDefaultRoute=$( ini.get route.default )

    : ${bDefaultRoute:=false}

    aReqOptByRole="host"

  ;;

  server)

      pool=$( ini.get pool.method )
      port=$( ini.get port )
    server=$( udfGetValidCIDR $( ini.get tunnel.cidr ) )

    :   ${pool:=dynamic}
    :   ${port:=12912}
    : ${server:=192.168.29.1/24}

    aReqOptByRole="server pool port"

  ;;

      *)

    eval $( udfOnError throw InvalidArgument "$role - must have client or server" )

  ;;

  esac

  cn=$( ini.get [ssl]cn )

  aId=( $( grep -Po '\044Id\072 \S+ \d+ \S+ \S+ \S+ \044' $0 ) ) && s=", (Ñ) ${aId[3]}, v${_kurenma_sVersion} rev${aId[2]}"
  udfDebug 1 "start $( _ s0 ) as ${role}${s}"

       dev=$( ini.get tunnel.name )
  portAuth=$( ini.get [ssl]port   )

  :      ${dev:=wg0}
  : ${portAuth:=42912}

  tsKeepalive=$( ini.get ts.keepalive )
  udfIsNumber $tsKeepalive || tsKeepalive=0
  (( tsKeepalive > 65355 )) && tsKeepalive=65355

  _bashlyk_OnError=return tsPeerTimeout=$( udfGetTimeInSec $( ini.get ts.timeout.peer ) "32min" )

  if (( tsPeerTimeout < 30 )); then

    eval $( udfOnError warn InvalidArgument "$tsPeerTimeout is too low, it increased to 30" )
    tsPeerTimeout=30

  fi

  if udfDebug 3; then

    ini.set [ __settings__ ] bConfMode = true
    echo -e "configuration:\n~~~~~~~~~~~~~~\n"
    ini.show
    echo -e "~~~~~~~~~~~~~~\n"
    ini.set [ __settings__ ] bConfMode = false

  fi

  udfThrowOnEmptyVariable cn dev pathCrt pathDat pathIni pathKey pathRun portAuth role tsPeerTimeout $aReqOptByRole

  fnCA=${pathCrt}/cacert.pem
  fnCrt=${pathCrt}/${cn}.crt
  fnKey=${pathKey}/${cn}.key

  [[ -d $_kurenma_pathLib ]] || eval $( udfOnError throw NoSuchFileOrDir "$_kurenma_pathLib" )
  [[ -s ${_kurenma_pathLib}/${role}.kurenma.src ]] || eval $( udfOnError throw NoSuchFileOrDir "${role}.kurenma.src" )

  . ${_kurenma_pathLib}/${role}.kurenma.src

  trap udfSignal 31

  udfService

  udfFinally "service down,"

}
#
#
#
udfMain
#
