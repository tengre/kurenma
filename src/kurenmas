#!/bin/bash
#
# $Id: kurenmas 17 2016-07-28 16:06:06+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
udfMakeFifo() {

	[[ -n "$1" ]] || eval $( udfOnError iErrorEmptyOrMissingArgument )
	udfMakeTemp $1 path=/var/run
	rm -f ${!1}
	mkfifo ${!1}

}
#
udfWaitRequest() {

	local -r iMax=64
	local i=0 s csv
	#
	while read s; do

		udfDebug 5 "input: ${s:0:10}.. ${i}" >&2
		csv+="${s}:"
		i=$((i+1))

		if (( $i > $iMax )); then

			echo "Warn: too many lines received, abort .." >&2
			break

		fi

		[[ $s =~ ^-----END.PKCS7-----$ ]] && break

	done

	if [[ $csv =~ ^-----BEGIN.PKCS7-----.*-----END.PKCS7-----:$ ]]; then

		udfDebug 5 "start request handling." >&2
		udfHandleRequest "$csv"

	else

		udfDebug 5 "connection does not imply data exchange.. $csv" >&2
		[[ -n "$csv" ]] && echo "unexpected.."

	fi
}
#
udfCheckNetcat() {

	udfIsNumber $1 || eval $( udfOnError throw iErrorNotValidArgument '$1' )
	local i p

	p="$( ps -C nc -o pid= -o args= | grep -w "$1" | xargs | cut -f 1 -d' ' )"

	udfIsNumber "$p" || return 1

	case "$2" in

		wait)
				udfIsNumber "$3" && i=$3 || i=8
				sleep $i
				;;

		kill)
				kill $p
				;;

	esac

	return 0

}
#
udfSelfCheck() {

	udfIsNumber $1 || eval $( udfOnError throw iErrorNotValidArgument '$1' )

	local fn iA iB iC=0

	fn=$( _ fnLog )

	while true; do

		sleep 16

		iB=$( sed -rn "/.* Connection from .* port .* .* accepted .*/{=}" $fn | tail -n 1 )

		sleep 16

		iA=$( sed -rn "/.* (Listening on .* .*|Connection closed, listening again.)/{=}" $fn | tail -n 1 )

		udfIsNumber "$iA" || iA=0
		udfIsNumber "$iB" || iB='-1'

		(( iA - iB > 0 )) && continue

		udfDebug 4 "selfcheck checkpoint - iA=$iA iB=$iB" >&2

		if (( iA == iC )); then

			udfDebug 4 "maybe netcat is hung - iA=$iA iB=$iB - try restart.." >&2
			udfCheckNetcat $1 kill

		else

			(( iA == -1 )) && iC=0 || iC=$iA
			sleep 16

		fi

	done

	return 0
}
#
udfHandleRequest() {

	## TODO udfThrowOnEmptyArgument
	[[ -n "$1" ]] || eval $( udfOnError retecho iErrorEmptyOrMissingArgument )

	udfThrowOnEmptyVariable fnServerKey ipServer dev pathCrt keepalive

	local fn fnLeased s keyPeer fnClientCrt cnClient ipClient IFS

	udfMakeTemp fn

	IFS=':'
	for s in $1; do

		echo $s

	done | openssl smime -decrypt -inform PEM -inkey $fnServerKey | tr -d '\r' > $fn
	IFS=$' \t\n'

	udfDebug 5 && {

		printf "\nreceived data:\n"
		cat $fn

	} >&2

	if [[ $( wc -l < $fn ) != 3 ]]; then

		echo "Error - unexpected format"
		eval $( udfOnError retwarn iErrorNotValidArgument "untrusted input data" ) >&2

	fi

	keyPeer="$( tail -n +3 $fn )"
	s=$( head -n 1 $fn )
	rm -f $fn

	for fn in $( ls $pathCrt ); do

		if [[ -f ${pathCrt}/${fn} && $fn =~ .crt ]]; then

			cnClient="$( grep 'Subject:' ${pathCrt}/${fn} | sed -re "s/.*CN=(.*)\/email.*/\1/" )"

		else

			continue

		fi

		[[ $s == $cnClient ]] || continue

		fnClientCrt=${pathCrt}/${fn}
		break

	done

	if [[ -z "$fnClientCrt" ]]; then

		echo "Error - unexpected request"
		eval $( udfOnError retecho iErrorNotPermitted "client certificate not found" )

	fi

	fnLeased=${path}/${cnServer}.${dev}.leased

	{

		udfDebug 4 && \
			printf "\nremote peer info:\n\tClient Common Name\t- %s\n\tPublic key for %s\t- %s\n" \
				"$cnClient" "$dev" "${keyPeer:0:10}.." >&2

		if [[ $(wg show $dev | grep peer | wc -l) -ge 253 ]]; then

			wg set $dev peer $(wg show $dev latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1) remove

		fi

		if [[ -s $fnLeased ]]; then

			## TODO check ip format
			ipClient=$( grep -P "^${cnClient}:\S+$" $fnLeased | tail -n 1 | cut -f 2 -d':' | xargs )

		fi

		if [[ -z "$ipClient" ]]; then

			ipClient=$( s="$( wg show $dev allowed-ips )"; for ((i=2; i<=254; i++)); do ip="${ipServer%.*}.$i"; [[ $s != *${ip}/32* ]] && echo $ip && break; done )

		fi

		if [[ -z "$ipClient" ]]; then

			echo "not allocated IP to the client"
			eval $( udfOnError retecho iErrorEmptyOrMissingArgument "not allocated IP to the client" ) >&2

		fi

		udfMakeTemp fn

		if wg set $dev peer "$keyPeer" allowed-ips "${ipClient}/32" persistent-keepalive $keepalive 2>$fn; then

			echo "OK:$( wg show $dev private-key | wg pubkey ):$( wg show $dev listen-port ):${ipClient}:${ipServer}"

			echo "${cnClient}:${ipClient}" >> $fnLeased
			cat $fnLeased | grep -P '^\S+:\S+$' | sort | uniq > $fn && mv $fn $fnLeased

		else

			echo "Error $(< $fn) $?"

		fi

	} | openssl smime -encrypt -outform PEM $fnClientCrt

	for s in $( wg show $dev allowed-ips | grep none | cut -f 1 | xargs ); do

		udfDebug 4 "${dev}: remove unused peer ${s:0:10}.."
		wg set $dev peer $s remove

	done >&2

	udfDebug 1 "server configuration updated." >&2

	udfDebug 3 && {

		printf "\n\nWireguard interface %s info:\n-----------------------------\n\n" "$dev"

		wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

		printf "\n----\n"

	} >&2

	wg showconf $dev > ${path}/${cnServer}.${dev}.conf
	chmod 0600 ${path}/${cnServer}.${dev}.conf

}
#
udfMain() {

	DEBUGLEVEL=5

	[[ $UID == 0 ]] || eval $( udfOnError throw iErrorNotPermitted "You must be root to run this." )

	local dev fn fnServerKey fnTmp ini ip ipServer ipClient keyPeer path pathKey pathCrt keepalive s

	udfThrowOnCommandNotFound cut echo grep ip kill nc openssl ps sort wg

	udfExitIfAlreadyStarted

	path=/etc/kurenma
	pathCrt=${path}/ssl/public
	pathKey=${path}/ssl/private
	ini=${path}/server.kurenma.ini

	udfIni $ini ':dev;port;portAuth;ipServer;keepalive ssl:cnServer'

	: ${dev:=wg0}
	: ${ipServer:=192.168.29.1}
	: ${port:=12912}
	: ${portAuth:=42912}
	udfIsNumber $keepalive && [[ $keepalive -gt 10 && $keepalive -lt 3600 ]] || keepalive=333

	udfDebug 2 && udfShowVariable dev ipServer port portAuth cnServer
	udfThrowOnEmptyVariable cnServer dev ipServer port portAuth

	if [[ -z "$( wg | grep $dev )" || -z "$( ip addr show $dev | grep $ipServer )" ]]; then

		ip link del dev $dev 2>/dev/null
		ip link add dev $dev type wireguard
		ip address add ${ipServer}/24 dev $dev
		wg set $dev private-key <(wg genkey) listen-port $port
		ip link set up dev $dev

	fi

	fnServerKey=${pathKey}/${cnServer}.key

	[[ -n $fnServerKey && -f $fnServerKey ]] || eval $(udfOnError exitecho iErrorNoSuchFileOrDir "$fnServerKey")

	udfCheckNetcat $portAuth kill

	udfSelfCheck $portAuth &
	udfAddPid2Clean $!

	while true; do

		udfDebug 4 "Daemon for Wireguard clients (re)started.."
		udfMakeFifo fnTmp
		cat $fnTmp | udfWaitRequest | nc -l -v $portAuth > $fnTmp
		## TODO exit command required for done
		rm -f $fnTmp

	done

}
#
#
#
udfMain
#
