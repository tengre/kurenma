#
# $Id: server.kurenma.src 167 2017-03-12 00:26:18+04:00 toor $"
#
#_bashlyk=kurenma _bashlyk_log=nouse . bashlyk
_bashlyk=kurenma . bashlyk
#
#
#
#
udmResetCounters() {

  bRevoked=0
  cn=''
  tsStart=0
  tsWait=60

}
#
udmCloseConnection() {

  udfDebug 3 "client $cn - exchange completed"

  udmResetCounters

  echo "exchange completed"
  sleep 1
  echo "q"

}
#
udmRevoked() {

  udfDebug 3 "client $cn cert revoked"
  echo "client cert revoked"

  udmCloseConnection

}
#
udmLimitConnectionTime() {

  udfIsNumber $1 \
    || eval $( udfOnError return InvalidArgument "$1 - number expected" )
  udfIsNumber $tsStart \
    || eval $( udfOnError return InvalidArgument "$tsStart - number expected" )

  (( tsStart > 0 )) || return 0
  [[ $cn ]] || eval $( udfOnError return EmptyArgument "cn" )

  local i=$(( $(date "+%s") - $tsStart ))

  (( i > 16 )) && udfDebug 3 "client $cn - exchange time is ${i}sec"

  if (( $i > $1 )); then

    udfDebug 3 "client $cn - exchange down by timeout ${i}sec"
    echo "client $cn - exchange down by timeout"

    udmCloseConnection

  fi

}
#
udfWaitRequest() {

  local bIssuer='false' bRevoked=0 cn rc s tsStart=0 tsWait=60

  while true; do

    read -t $tsWait s
    rc=$?

    if   (( rc > 128 )); then

      (( bRevoked > 0 )) && udmRevoked

      if (( tsStart == 0 )); then

        udfDebug 3 "wait ${tsWait}sec"
        tsWait=$(( tsWait + 10 ))

      fi

    elif (( rc > 0 )); then

      udfDebug 3 "input closed"
      break

    elif [[ $s =~ ^signalStop$ ]]; then

      udfDebug 3 "SSL server down"

      echo Q
      sleep 0.2
      break

    elif [[ $s =~ ^verify.*revoked.* ]]; then

      udfDebug 3 "warn: $cn revoked certificate"
      bRevoked=1
      tsWait=2

    elif [[ $s =~ depth=0.*CN.* ]]; then

      rc="${s/depth=0/subject:}"
      s="${s##*, CN = }"
      s="${s%,*}"

      [[ "$s" == "$cn" ]] && continue || cn=$s

      udfDebug 3 "client $cn - exchange started"
      udfDebug 3 "SSL: $rc"
      rc=0

      tsStart=$(date "+%s")
      tsWait=4

    elif [[ $bIssuer == 'false' && $s =~ depth=1.*CN.* ]]; then

      udfDebug 3 "SSL: ${s/depth=1/ issuer:}"
      bIssuer='true'

    elif [[ $s =~ client-data.* ]]; then

      if (( bRevoked > 0 )); then

        udfDebug 3 "client data ignored"

      else

        s=${s##*client-data}
        udfDebug 5 "client data: ${s:1:10}<skip>"
        udfHandleRequest $cn ${s:1:45}

        sleep 0.1
        udmCloseConnection

      fi

    elif [[ $s =~ ^(CIPHER|ERROR|ACCEPT) ]];
    then

      udfDebug 3 "SSL: $s"

    fi

    udmLimitConnectionTime 32

  done

}
#
udfHandleRequest() {

  udfThrowOnEmptyOrMissingArgument "$1" "$2"
  udfThrowOnEmptyVariable dev pathDat pathIni pool tsKeepalive tsPeerTimeout   \
                          server

  local aCIDR cmdWG cnClient fmt fn fnLeased i ip ipClient peer s

  cnClient=$1
  peer=$2
  fmt="\n%s - prepare tunnel settings (client public key=%s) on %s:\n"

  fnLeased=${pathDat}/${cn}.${dev}.leased

  udfDebug 4 && printf -- "$fmt" "$cnClient" "${peer:0:10}<skip>" "$dev" >&2

  if [[ $(wg show $dev | grep peer | wc -l) -ge 253 ]]; then

    wg set $dev peer $(                                                        \
                                                                               \
      wg show $dev latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1  \
                                                                               \
    ) remove

  fi

  for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

    if udfIsNumber ${s##*:}; then

      #ignore too low timestamps
      (( ${s##*:} < 1800 )) && continue

      i=$(( $(date +%s) - ${s##*:} ))

      if (( i >= tsPeerTimeout )); then

        wg set $dev peer ${s%%:*} remove
        udfDebug 2 \
          "peer ${s:0:10}<skip> is removed due to inactivity over an ${i}s.. $?"

      fi

    else

      eval $( udfOnError warn InvalidArgument "${s##*:}" )

    fi

  done

  if [[ "$pool" == "commonname" ]]; then

    ## TODO IP must be in the server network - checking required
    s="$cnClient - lease of the IP by Common Name"
    if ipClient=$( udfGetValidIPsOnly $cnClient ); then
      udfDebug 3 "$s - $ipClient"
    else
      udfDebug 3 "$s - not resolved.."
    fi

  fi

  if [[ ! $ipClient || $pool == "dynamic" ]]; then

    [[ -f $fnLeased ]] || touch $fnLeased

    ipClient=$(                                                                \
                                                                               \
      grep -P "^${cnClient}:\S+$" $fnLeased |tail -n 1| cut -f 2 -d':'|xargs   \
                                                                               \
    )

    ipClient=$( udfGetValidIPsOnly $ipClient )
    s="$cnClient - lease of the already used IP"
    udfDebug 3 "$s - $ipClient"

  fi

  if [[ ${server%/*} == $ipClient ]]; then

    eval $(                                                                    \
                                                                               \
      udfOnError warn InvalidArgument                                          \
        "the IP address $ipClient is already in use, skipped"                  \
                                                                               \
    )

    unset ipClient

  fi

  if [[ ! $ipClient ]]; then

    ipClient=$(( ${server%/*} ))
    s="$( wg show $dev allowed-ips )"
    ## TODO ip range for pool
    for ((i=$(( ${ipClient##*.} + 1 )); i<=254; i++)); do

      ip="${ipClient%.*}.$i";

      if [[ $s =~ ${ip}/32 ]]; then

        continue

      else

        ipClient=$( udfGetValidIPsOnly $ip )
        s="$cnClient - lease of the dynamic IP"
        udfDebug 3 "$s - $ipClient"
        break

      fi

    done

  fi

  if [[ ! $ipClient || ${server%/*} == $ipClient ]]; then

    echo "not allocated IP to the client"
    eval $(                                                                    \
                                                                               \
      udfOnError retecho InvalidArgument "not allocated IP to the client"      \
                                                                               \
    )

  fi

  aCIDR=$( udfGetValidCIDR ${ipClient}/32 ${aIpsAllowed[@]} )

  udfDebug 3 "$cnClient - allowed ips - $aCIDR"

  udfMakeTemp fn

  cmdWG="$(                                                                    \
                                                                               \
    printf -- 'wg set %s peer %s allowed-ips %s persistent-keepalive %d'       \
              "$dev" "$peer" "${aCIDR// /,}" "$tsKeepalive"                    \
                                                                               \
  )"

  if $cmdWG 2>$fn; then

    printf -- 'OK:%s:%s:%s:%s\n'                                               \
              "$( wg show $dev private-key | wg pubkey )"                      \
              "$( wg show $dev listen-port )"                                  \
              "${ipClient}"                                                    \
              "${server%/*}"

    for s in $( wg show $dev peers ); do

      grep ":${s:0:10}$" $fnLeased

    done > $fn

    mv -f $fn $fnLeased
    echo "${cnClient}:${ipClient}:$(date +%s):${peer:0:10}" >> $fnLeased

  else

    echo "Error $(< $fn) $?"
    rm -f $fn

  fi

  for s in $( wg show $dev allowed-ips | grep none | cut -f 1 | xargs ); do

    wg set $dev peer $s remove
    udfDebug 3 "${dev}: peer ${s:0:10}<skip> is removed as unused .. $?"

  done

  udfDebug 1 "server configuration updated."

  wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
  chmod 0600 ${pathIni}/${cn}.${dev}.conf

}
#
udfSetupTunnel() {

  udfThrowOnEmptyVariable dev server port

  udfDebug 3 && printf -- "Init WireGuard device %s" "$dev"

  try {

    ip link del dev $dev 2>/dev/null || true
    ip link add dev $dev type wireguard
    ip address add $server dev $dev
    wg set $dev private-key <(wg genkey) listen-port $port
    ip link set up dev $dev

  } catch {

    ERR::exception.message
    exit $?

  }

  udfDebug 3 "init new server pub key: \
    $( wg show $dev private-key | wg pubkey | head -c 10 )<skip>"

  return 0

}
#
udfService() {

  DEBUGLEVEL=5

  [[ $UID == 0 ]] || eval $(                                                   \
                                                                               \
    udfOnError throw NotPermitted "You must be root to run this."              \
                                                                               \
  )

  udfThrowOnCommandNotFound cut kill ps sort
  udfThrowOnEmptyVariable cn dev fnCrt fnKey pathCA pathCrt pathKey port \
                          portAuth server

  local cmdSSL fn fnDH

  if [[ ! ( $( wg|grep $dev ) && $( ip addr show $dev|grep ${server%/*} ) ) ]];
  then

    udfSetupTunnel

  fi

  fnDH=${pathCrt}/dh2048.pem

  cmdSSL="                                                                     \
    openssl s_server -cert $fnCrt -key $fnKey -accept $portAuth                \
      -CApath $pathCA -Verify 2 -crl_check_all -dhparam $fnDH                  \
  "

  udfStopProcess $cmdSSL

  while true; do

    udfDebug 3 "Daemon for WireGuard clients (re)started.."

    udfMakeTemp fn type=pipe

    export _kurenma_control_channel=$fn
    udfWaitRequest < $fn | $cmdSSL > $fn 2>&1 &
    udfAddPid2Clean $!
    wait $!
    rm -f $fn

    udfWaitSignal 0.2 || break

  done

}
#
#
#
