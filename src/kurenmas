#!/bin/bash
#
_kurenmas_sVersion=0.2
eval "_kurenmas_aRev=($Id: kurenmas 32 2016-08-16 00:19:38+04:00 toor $)"
#
_bashlyk=kurenma . bashlyk
#
#
#
udfUsage() {

    	local sVersion="$_kurenmas_sVersion (${_kurenmas_aRev[3]}rev${_kurenmas_aRev[2]})"

	printf -- "\t%s v%s, Kurenma Service for WireGuard tunnels, (c) 2016\n" "$(_ s0)" "${sVersion}"

#****h* kurenma/kurenmas
#  DESCRIPTION
#    kurenmas - Kurenma Service for WireGuard tunnels
#  AUTHOR
#    Damir Sh. Yakupov <yds@bk.ru>
#  ARGUMENTS
	cat <<-EOF | tr -d '#'

		Usage: $(_ s0) start|stop
		where:

#			start	- start service
#			stop	- stop  service
#
#		without arguments show this usage and exit

	EOF
	eval $(udfOnError exit)

}
#******
shopt -s expand_aliases
alias try="udfTry <<-catch.e"
#
udfTry() {

    local s b=true fn i=0
    #
    udfMakeTemp fn
    #
    while read s; do

	i=$((i+1))

	[[ -n "$s" ]] || continue

	eval "$s" > $fn 2>&1 && echo -n "." || {

		_ iTryBlockLine $i
		b=false
		break
	}

    done

    if ! $b; then

	echo "?"
	udfStackTrace $s
	eval $( udfOnError exitwarn $i "line: $i, code: $s, output: $(< $fn)" )

    fi

}
#
udfMakeFifo() {

	[[ -n "$1" ]] || eval $( udfOnError iErrorEmptyOrMissingArgument )
	udfMakeTemp $1 path=$( _ pathRun )
	rm -f ${!1}
	mkfifo ${!1}

}
#
udfGetTimeInSec() {

	if [[ "$1" == "-v" ]]; then

		udfIsValidVariable "$2" || eval $( udfOnError iErrorNotValidArgument "$2 - variable name required" ) >&2

		[[ "$3" == "-v" ]] && eval $( udfOnError iErrorNotValidArgument "$3 - number with time suffix expected" ) >&2

		eval 'export $2="$( udfGetTimeInSec $3 )"'
		[[ -n ${!2} ]] || eval 'export $2="$( udfGetTimeInSec $4 )"'
		[[ -n ${!2} ]] || eval $( udfOnError iErrorEmptyResult "$2 - empty variable" ) >&2

		return $?

	fi

	local i=${1%%[[:alpha:]]*}

	udfIsNumber $i || eval $( udfOnError iErrorNotValidArgument "$i - number expected" ) >&2

	case ${1##*[[:digit:]]} in

	second|secon|seco|sec|se|s|'') echo $i;;
	   minute|minut|minu|min|mi|m) echo $(( i*60 ));;
		     hour|hou|ho|hr|h) echo $(( i*3600 ));;
		             day|da|d) echo $(( i*3600*24 ));;
		        week|wee|we|w) echo $(( i*3600*24*7 ));;
		      month|mon|mo|mn) echo $(( i*3600*24*30 ));;
		               year|y) echo $(( i*3600*24*365 ));;
                                    *) echo ""
                                       eval $( udfOnError iErrorNotValidArgument "$1 - number with time suffix expected" ) >&2

	esac

    return $?

}
#
udfGetValidIPsOnly() {

	[[ -n "$*" ]] || eval $( udfOnError return iErrorEmptyOrMissingArgument )

	local s sDig sOut

	for s in $*; do

		[[ $s =~ ^[0-9.]+$ ]] && ipcalc "$s" | grep '^INVALID ADDRESS:' && continue
		sipcalc -d4 "$s" | grep '^-\[ERR :' && continue
		sDig=$( dig +short $s | xargs )
		[[ -n "$sDig" ]] && s="$sDig"
		sOut+="$s "

	done >/dev/null 2>&1

	echo ${sOut% *} | tr ' ' '\n' | sort | uniq | xargs

	return 0

}
#
udfCheckNetcat() {

	udfIsNumber $1 || eval $( udfOnError throw iErrorNotValidArgument '$1' )
	local i p

	p="$( ps -C nc -o pid= -o args= | grep -w "$1" | xargs | cut -f 1 -d' ' )"

	udfIsNumber "$p" || return 1

	case "$2" in

		wait)
				udfIsNumber "$3" && i=$3 || i=8
				sleep $i
				;;

		kill)
				kill -15 $p
				sleep 0.5
				p="$( ps -C nc -o pid= -o args= | grep -w "$1" | xargs | cut -f 1 -d' ' )"
				[[ -n $p ]] && kill -9 $p
				;;

	esac

	return 0

}
#
udfSelfCheck() {

	udfIsNumber $1 || eval $( udfOnError throw iErrorNotValidArgument '$1' )

	local fn iA iB iC=0 s

	fn=$( _ fnLog )

	while true; do

		## TODO check peers expiring
		## TODO implement auto sleep mode

		for s in 5 4 3 2 1; do sleep $s; done

		iB=$( sed -rn "/.* Connection from .* port .* .* accepted .*/{=}" $fn | tail -n 1 )

		for s in 5 4 3 2 1; do sleep $s; done

		iA=$( sed -rn "/.* (Listening on .* .*|Connection closed, listening again.)/{=}" $fn | tail -n 1 )

		udfIsNumber "$iA" || iA=0
		udfIsNumber "$iB" || iB='-1'

		(( iA - iB > 0 )) && continue

		udfDebug 4 "selfcheck checkpoint - iA=$iA iB=$iB" >&2

		if (( iA == iC )); then

			udfDebug 4 "maybe netcat is hung - iA=$iA iB=$iB - try restart.." >&2
			udfCheckNetcat $1 kill

		else

			(( iA == -1 )) && iC=0 || iC=$iA
			for s in 5 4 3 2 1; do sleep $s; done

		fi

	done

	return 0
}
#
udfWaitRequest() {

	local -r iMax=32
	local i=0 s csv
	#
	while read -n 66 s; do

		udfDebug 5 "input line ${i}: ${s:0:10}<skipped>" >&2

		if [[ $s =~ ^-----BEGIN.PKCS7-----$ ]]; then

			csv=""
			i=0

		fi

		csv+="${s}:"
		i=$((i+1))

		if (( $i > $iMax )); then

			echo "Warn: too many lines received, ignore .." >&2
			csv=""
			i=0

		fi

		if [[ $csv =~ ^-----BEGIN.PKCS7-----.*-----END.PKCS7-----:$ ]]; then

			udfDebug 5 "start request handling." >&2
			udfHandleRequest "$csv"
			csv=""
			i=0

		fi

	done

}
#
udfHandleRequest() {

	## TODO udfThrowOnEmptyArgument
	[[ -n "$1" ]] || eval $( udfOnError retecho iErrorEmptyOrMissingArgument )

	local csvCIDR cnClient fn fnClientCrt fnLeased keyPeer s

	udfThrowOnEmptyVariable fnServerKey ipClient ipServer dev pathCrt pathDat pathIni tsExpired tsKeepalive

	udfMakeTemp fn

	printf -- "${1//:/\\n}" | openssl smime -decrypt -inform PEM -inkey $fnServerKey | tr -d '\r' > $fn

	udfDebug 5 && {

		printf -- "\nreceived data:\n--------------\n"
		head -n 2 $fn
		echo "$( tail -n +3 $fn | head -c 10 )<skipped>"
		echo "--------------"

	} >&2

	if [[ $( wc -l < $fn ) != 3 ]]; then

		echo "Error - unexpected format"
		eval $( udfOnError retwarn iErrorNotValidArgument "untrusted input data" ) >&2

	fi

	keyPeer="$( tail -n +3 $fn )"
	s=$( head -n 1 $fn )
	rm -f $fn

	for fn in $( ls $pathCrt ); do

		if [[ -f ${pathCrt}/${fn} && $fn =~ .crt ]]; then

			cnClient="$( grep 'Subject:' ${pathCrt}/${fn} | sed -re "s/.*CN=(.*)\/email.*/\1/" )"

		else

			continue

		fi

		[[ $s == $cnClient ]] || continue

		fnClientCrt=${pathCrt}/${fn}
		break

	done

	if [[ -z "$fnClientCrt" ]]; then

		echo "Error - unexpected request"
		eval $( udfOnError retecho iErrorNotPermitted "client certificate not found" ) >&2

	fi

	fnLeased=${pathDat}/${cnServer}.${dev}.leased

	{

		udfDebug 4 && \
			printf -- "\nremote peer info:\n\tClient Common Name\t- %s\n\tPublic key for %s\t- %s\n" \
				"$cnClient" "$dev" "${keyPeer:0:10}<skipped>" >&2

		if [[ $(wg show $dev | grep peer | wc -l) -ge 253 ]]; then

			wg set $dev peer $(wg show $dev latest-handshakes | sort -k 2 -b -n | head -n 1 | cut -f 1) remove

		fi

		for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

			if udfIsNumber ${s##*:}; then


				if (( $(date +%s) - ${s##*:} >= tsExpired )); then

					wg set $dev peer ${s%%:*} remove
					udfDebug 4 "peer ${s:0:10}<skipped> removed .. $?" >&2

				fi

			else

				eval $( udfOnError warn iErrorNotValidArgument "${s##*:}" ) >&2

			fi

		done

		if [[ "$ipClient" == "commonname" ]]; then

			ipClient=$( udfGetValidIPsOnly $cnClient )
			udfDebug 5 "Leased IP by CN to $cnClient - $ipClient" >&2

		fi

		if [[ -z "$ipClient" || $ipClient == "dynamic" ]]; then

			[[ -f $fnLeased ]] || touch $fnLeased

			ipClient=$( grep -P "^${cnClient}:\S+$" $fnLeased | tail -n 1 | cut -f 2 -d':' | xargs )
			ipClient=$( udfGetValidIPsOnly $ipClient )

		fi

		if [[ -z "$ipClient" ]]; then

			ipClient=$( s="$( wg show $dev allowed-ips )"; for ((i=2; i<=254; i++)); do ip="${ipServer%.*}.$i"; [[ $s != *${ip}/32* ]] && echo $ip && break; done )
			ipClient=$( udfGetValidIPsOnly $ipClient )

		fi

		if [[ -z "$ipClient" ]]; then

			echo "not allocated IP to the client"
			eval $( udfOnError retecho iErrorEmptyOrMissingArgument "not allocated IP to the client" ) >&2

		fi

		csvCIDR="${ipClient}/32"

		for s in ${ipsAllowed//[;,]/ }; do

			[[ -n "$( udfGetValidIPsOnly ${s%/*} )" ]] || continue

			if [[ $s == ${s##*/} ]]; then

				s="$( udfGetValidIPsOnly ${s%/*} )"

			else

				udfIsNumber "${s##*/}" && (( "${s##*/}" > 33 )) && continue
				udfIsNumber "${s##*/}" || continue

			fi

			csvCIDR+=",$s"

		done

		udfDebug 5 "allowed-ips: $csvCIDR" >&2

		udfMakeTemp fn
		if wg set $dev peer "$keyPeer" allowed-ips "$csvCIDR" persistent-keepalive $tsKeepalive 2>$fn; then

			echo "OK:$( wg show $dev private-key | wg pubkey ):$( wg show $dev listen-port ):${ipClient}:${ipServer}"

			echo "${cnClient}:${ipClient}" >> $fnLeased
			cat $fnLeased | grep -P '^\S+:\S+$' | sort | uniq > $fn && mv $fn $fnLeased

		else

			echo "Error $(< $fn) $?"

		fi

	} | openssl smime -encrypt -outform PEM $fnClientCrt

	for s in $( wg show $dev allowed-ips | grep none | cut -f 1 | xargs ); do

		wg set $dev peer $s remove
		udfDebug 4 "${dev}: remove unused peer ${s:0:10}<skipped> .. $?"

	done >&2

	udfDebug 1 "server configuration updated." >&2

	udfDebug 3 && {

		printf -- "\n\nWireGuard interface %s info:\n-----------------------------\n\n" "$dev"

		wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

		printf -- "\n----\n"

	} >&2

	wg showconf $dev > ${pathIni}/${cnServer}.${dev}.conf
	chmod 0600 ${pathIni}/${cnServer}.${dev}.conf

}
#
udfMain() {

	[[ $UID == 0 ]] || eval $( udfOnError throw iErrorNotPermitted "You must be root to run this." )

	local dev fn fnPid fnServerKey fnTmp ini ip ipClient ipServer ipsAllowed pathIni pathCrt pathDat pathKey s tsExpired tsKeepalive

	DEBUGLEVEL=4

	udfThrowOnCommandNotFound cut dig echo grep ip ipcalc kill mkdir nc openssl ps sipcalc sort uniq wg

	pathIni=$( _ pathIni )
	pathDat=$( _ pathDat )
	pathRun=$( _ pathRun )

	pathCrt=${pathIni}/ssl/public
	pathKey=${pathIni}/ssl/private
	ini=${pathIni}/server.kurenma.ini

	udfIni $ini ':dev;port;portAuth;ipClient;ipServer;tsExpired;tsKeepalive ssl:cnServer ipsAllowed:='

	: ${dev:=wg0}
	: ${ipClient:=dynamic}
	: ${ipServer:=192.168.29.1}
	: ${port:=12912}
	: ${portAuth:=42912}
	: ${tsExpired:=2day}

	eval set -- $(_ sArg)

	case "$1" in

		start)
			udfDebug 1 "service kurenmas starting.."

			export _kurenmas_ctl=start
			( kurenmas & ) &

			return 0
		;;

		 stop)
			udfDebug 1 "service kurenmas stopping.."
			fnPid=${pathRun}/kurenmas.pid
			echo stop >> $fnPid
			[[ -n $portAuth ]] && udfCheckNetcat $portAuth kill
			return 0
		;;

		    *)
			if [[ "$_kurenmas_ctl" == "start" ]]; then
				echo "starting.."
				unset _kurenmas_ctl
			else
				udfDebug 1 && udfUsage
				return 1
			fi
		;;

	esac


	udfDebug 4 "$( _ sId ) (с) ${_kurenmas_aRev[3]}, rev${_kurenmas_aRev[2]}"

	udfExitIfAlreadyStarted
	fnPid=$( _ fnPid )

	if udfIsNumber $tsKeepalive; then

		(( $tsKeepalive <= 65355 )) || tsKeepalive=65355

	else

		tsKeepalive=0

	fi

	_bashlyk_sBehaviorOnError=return udfGetTimeInSec -v tsExpired $tsExpired "2day"

	udfDebug 2 && udfShowVariable dev ipServer port portAuth cnServer ipsAllowed tsExpired tsKeepalive
	udfThrowOnEmptyVariable cnServer dev ipServer pathDat pathIni port portAuth tsExpired

	mkdir -p $pathDat || eval $( udfOnError retecho iErrorNotExistNotCreated $pathDat )

	if [[ -z "$( wg | grep $dev )" || -z "$( ip addr show $dev | grep $ipServer )" ]]; then

		try

			ip link del dev $dev 2>/dev/null || true
			ip link add dev $dev type wireguard
			ip address add ${ipServer}/24 dev $dev
			wg set $dev private-key <(wg genkey) listen-port $port
			ip link set up dev $dev
			udfDebug 4 "init new server pub key: $( wg show $dev private-key | wg pubkey | head -c 10 )<skipped>"

		catch.e

	fi

	fnServerKey=${pathKey}/${cnServer}.key

	[[ -n $fnServerKey && -f $fnServerKey ]] || eval $(udfOnError exitecho iErrorNoSuchFileOrDir "$fnServerKey")

	udfCheckNetcat $portAuth kill

	echo "start" >> $fnPid
	udfSelfCheck $portAuth &
	udfAddPid2Clean $!

	while true; do

		udfDebug 4 "Daemon for WireGuard clients (re)started.."
		udfMakeFifo fnTmp
		cat $fnTmp | udfWaitRequest | nc -k -l -v $portAuth > $fnTmp
		sleep 1
		[[ ! -s $fnPid || $( tail -n 1 $fnPid ) == "stop" ]] && break
		rm -f $fnTmp

	done

	udfFinally "."

}
#
#
#
udfMain
#
