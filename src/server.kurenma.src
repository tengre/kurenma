#
# $Id: server.kurenma.src 175 2017-12-31 01:15:33+04:00 toor $"
#
_bashlyk=kurenma . bashlyk
#
#
#
#
kurenma-server::resetCounters() {

  bRevoked=0
  cn=''
  tsStart=0
  tsWait=60

}
#
kurenma-server::closeConnection() {

  err::debug 3 "client $cn - exchange completed"

  kurenma-server::resetCounters

  echo "exchange completed"
  sleep 1
  echo "q"

}
#
kurenma-server::revoked() {

  err::debug 3 "client $cn cert revoked"
  echo "client cert revoked"

  kurenma-server::closeConnection

}
#
kurenma-server::limitConnectionTime() {

  std::isNumber $1       || on error return NotNumber "first argument"
  std::isNumber $tsStart || on error return NotNumber "$tsStart"

  (( tsStart > 0 )) || return 0
  [[ $cn ]] || on error return EmptyArgument "cn"

  local i=$(( $( exec -c date "+%s" ) - $tsStart ))

  (( i > 16 )) && err::debug 3 "client $cn - exchange time is ${i}sec"

  if (( $i > $1 )); then

    err::debug 3 "client $cn - exchange down by timeout ${i}sec"
    echo "client $cn - exchange down by timeout"

    kurenma-server::closeConnection

  fi

}
#
kurenma-server::waitRequest() {

  local bIssuer='false' bRevoked=0 cn rc s tsStart=0 tsWait=60

  while true; do

    read -t $tsWait s
    rc=$?

    if   (( rc > 128 )); then

      (( bRevoked > 0 )) && kurenma-server::revoked

      if (( tsStart == 0 )); then

        err::debug 3 "wait ${tsWait}sec"
        tsWait=$(( tsWait + 10 ))

      fi

    elif (( rc > 0 )); then

      err::debug 3 "input closed"
      break

    elif [[ $s =~ ^signalStop$ ]]; then

      err::debug 3 "SSL server down"

      echo Q
      sleep 0.2
      break

    elif [[ $s =~ ^verify.*revoked.* ]]; then

      err::debug 3 "warn: $cn revoked certificate"
      bRevoked=1
      tsWait=2

    elif [[ $s =~ depth=0.*CN.* ]]; then

      rc="${s/depth=0/subject:}"
      s="${s##*, CN = }"
      s="${s%,*}"

      [[ "$s" == "$cn" ]] && continue || cn=$s

      err::debug 3 "client $cn - exchange started"
      err::debug 3 "SSL: $rc"
      rc=0

      tsStart=$( exec -c date "+%s" )
      tsWait=4

    elif [[ $bIssuer == 'false' && $s =~ depth=1.*CN.* ]]; then

      err::debug 3 "SSL: ${s/depth=1/ issuer:}"
      bIssuer='true'

    elif [[ $s =~ client-data.* ]]; then

      if (( bRevoked > 0 )); then

        err::debug 3 "client data ignored"

      else

        s=${s##*client-data}
        err::debug 5 "client data: ${s:1:10}<skip>"
        kurenma-server::handleRequest $cn ${s:1:45}

        sleep 0.1
        kurenma-server::closeConnection

      fi

    elif [[ $s =~ ^(CIPHER|ERROR|ACCEPT) ]];
    then

      err::debug 3 "SSL: $s"

    fi

    kurenma-server::limitConnectionTime 32

  done

}
#
kurenma-server::handleRequest() {

  throw on MissingArgument "$1" "$2"

  throw on EmptyVariable dev pathDat pathIni pool tsKeepalive tsPeerTimeout server

  local aCIDR cmdWG cnClient fmt fn fnLeased i ip ipClient peer s

  cnClient=$1
  peer=$2
  fmt="\n%s - prepare tunnel settings (client public key=%s) on %s:\n"

  fnLeased=${pathDat}/${cn}.${dev}.leased

  err::debug 4 && printf -- "$fmt" "$cnClient" "${peer:0:10}<skip>" "$dev" >&2

  for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

    if std::isNumber ${s##*:}; then

      #ignore too low timestamps
      (( ${s##*:} < 1800 )) && continue

      i=$(( $( exec -c date +%s ) - ${s##*:} ))

      if (( i >= tsPeerTimeout )); then

        wg set $dev peer ${s%%:*} remove
        err::debug 2 \
          "peer ${s:0:10}<skip> is removed due to inactivity over an ${i}s.. $?"

      fi

    else

      on error warn InvalidArgument "${s##*:}"

    fi

  done

  if [[ "$pool" == "commonname" ]]; then

    if ipClient=$( net::ipv4.host $cnClient ); then

      if grep -w $ipClient < <( net::ipv4.range $server ) >/dev/null 2>&1; then

        err::debug 3 "$cnClient - lease of the IP by Common Name $ipClient"

      else

        err::debug 3 "$cnClient - $ipClient is out of range for tunnel $server"
        ipClient=''

      fi

    else

      err::debug 3 "$cnClient - IP-address by Common Name not resolved.."

    fi

  fi

  if [[ ! $ipClient || $pool == "dynamic" ]]; then

    [[ -f $fnLeased ]] || touch $fnLeased

    ipClient=$(                                                                \
                                                                               \
      grep -P "^${cnClient}:\S+$" $fnLeased |tail -n 1| cut -f 2 -d':'|xargs   \
                                                                               \
    )

    if ipClient=$( net::ipv4.host $ipClient ); then

      err::debug 3 "$cnClient - lease of the early used IP $ipClient"

    else

      ipClient=''

    fi

  fi

  if [[ ${server%/*} == $ipClient ]]; then

    err::debug 3 "the IP address $ipClient is already in use, skipped"

    ipClient=''

  fi

  if [[ ! $ipClient ]]; then

    s="$( exec -c wg show $dev allowed-ips )"

    for ipClient in $( net::ipv4.range $server ); do

      [[ $s =~ ${ipClient}/32 ]] && continue

      err::debug 3 "$cnClient - lease of the dynamic IP - $ipClient"
      break

    done

  fi

  if [[ ! $ipClient || ${server%/*} == $ipClient ]]; then

    on error warn+return InvalidArgument "not allocated IP to the client.."

  fi

  aCIDR=$( net::ipv4.cidr ${ipClient}/32 ${aIpsAllowed[@]} )

  err::debug 3 "$cnClient - allowed ips - $aCIDR"

  std::temp fn

  cmdWG="$(                                                                    \
                                                                               \
    printf -- 'wg set %s peer %s allowed-ips %s persistent-keepalive %d'       \
              "$dev" "$peer" "${aCIDR// /,}" "$tsKeepalive"                    \
                                                                               \
  )"

  if $cmdWG 2>$fn; then

    printf -- 'OK:%s:%s:%s:%s\n'                                               \
              "$( wg show $dev private-key | wg pubkey )"                      \
              "$( exec -c wg show $dev listen-port )"                          \
              "${ipClient}"                                                    \
              "${server%/*}"

    for s in $( exec -c wg show $dev peers ); do

      grep ":${s:0:10}$" $fnLeased

    done > $fn

    mv -f $fn $fnLeased
    echo "${cnClient}:${ipClient}:$(exec -c date +%s):${peer:0:10}" >> $fnLeased

  else

    echo "Error $(< $fn) $?"
    rm -f $fn

  fi

  for s in $( wg show $dev allowed-ips | grep none | cut -f 1 | xargs ); do

    wg set $dev peer $s remove
    err::debug 3 "${dev}: peer ${s:0:10}<skip> is removed as unused .. $?"

  done

  err::debug 1 "server configuration updated."

  wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
  chmod 0600 ${pathIni}/${cn}.${dev}.conf

}
#
kurenma-server::setupTunnel() {

  throw on EmptyVariable dev server port

  err::debug 3 && printf -- "Init WireGuard device %s" "$dev"

  try {

    ip link del dev $dev 2>/dev/null || true
    ip link add dev $dev type wireguard
    ip address add $server dev $dev
    wg set $dev private-key <(wg genkey) listen-port $port
    ip link set up dev $dev

  } catch {

    err::exception.message
    exit $?

  }

  err::debug 3 "init new server pub key: \
    $( wg show $dev private-key | wg pubkey | head -c 10 )<skip>"

  return 0

}
#
# exported function
#
kurenma-daemon::service() {

  DEBUGLEVEL=5

  [[ $UID == 0 ]] || on error warn+exit NotPermitted "You must be root to run this."

  exit+warn on CommandNotFound cut kill ps sort

  throw on EmptyVariable cn dev fnCrt fnKey pathCA pathCrt pathKey protocol    \
                         port portAuth server

  local cmdSSL fn fnDH

  if [[ ! ( $( wg|grep $dev ) && $( ip addr show $dev|grep ${server%/*} ) ) ]];
  then

    kurenma-server::setupTunnel

  fi

  fnDH=${pathCrt}/dh2048.pem

  cmdSSL="$(                                                                   \
                                                                               \
    printf --                                                                  \
      "openssl s_server -Verify 2 -crl_check_all                               \
       -accept %s                                                              \
       -%s                                                                     \
       -dhparam %s                                                             \
       -CApath %s                                                              \
       -cert %s                                                                \
       -key %s                                                                 \
      "                                                                        \
      "$portAuth"                                                              \
      "$protocol"                                                              \
      "$fnDH"                                                                  \
      "$pathCA"                                                                \
      "$fnCrt"                                                                 \
      "$fnKey"                                                                 \
                                                                               \
  )"

  cmdSSL=$( std::trim $cmdSSL )

  err::debug 6 "openssl command line: $cmdSSL"

  pid::stop openssl s_.*kurenma

  while true; do

    err::debug 3 "Daemon for WireGuard clients (re)started.."

    std::temp fn type=pipe

    export _kurenma_control_channel=$fn

    kurenma-server::waitRequest < $fn | $cmdSSL > $fn 2>&1 &

    pid::onExit.stop $!

    wait $!
    rm -f $fn

    kurenma-daemon::waitSignal 0.2 || break

  done

}
#
#
#
