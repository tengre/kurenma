#!/bin/bash
#
# $Id: kurenmac 25 2016-08-04 23:13:09+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
udfGetValidIPsOnly() {

	[[ -n "$*" ]] || eval $( udfOnError return iErrorEmptyOrMissingArgument )

	local s sDig sOut

	for s in $*; do

		[[ $s =~ ^[0-9.]+$ ]] && ipcalc "$s" | grep '^INVALID ADDRESS:' && continue
		sipcalc -d4 "$s" | grep '^-\[ERR :' && continue
		sDig=$( dig +short $s | xargs )
		[[ -n "$sDig" ]] && s="$sDig"
		sOut+="$s "

	done >/dev/null 2>&1

	echo ${sOut% *} | tr ' ' '\n' | sort | uniq | xargs

	return 0

}
#
udfMain() {

	[[ $UID == 0 ]] || eval $( udfOnError throw  iErrorNotPermitted "You must be root to run this." )

	local a cnClient cnServer dev fn fnAns fnClientCrt fnClientKey fnKey fnPub fnServerCrt host i ini ipClient ipServer keepalive pathCrt pathIni pathKey peer port s

	DEBUGLEVEL=5

	udfThrowOnCommandNotFound echo ip ipcalc dig grep knock openssl ping printf sed sipcalc tee wg

	pathIni=$( _ pathIni )
	ini=${pathIni}/client.kurenma.ini
	pathCrt=${pathIni}/ssl/public
	pathKey=${pathIni}/ssl/private

	udfIni $ini ':dev;host;port;keepalive ssl:cnServer;cnClient'

	: ${dev:=wg0}
	: ${i:=256}

	if udfIsNumber $keepalive; then

		(( $keepalive >= 10   )) || keepalive=10
		(( $keepalive <= 3600 )) || keepalive=3600

	else

		keepalive=0

	fi

	udfDebug 2 "configuration:" && udfShowVariable dev host port cnServer cnClient keepalive
	udfThrowOnEmptyVariable cnClient cnServer dev host pathIni port

	fnServerCrt=${pathCrt}/${cnServer}.crt
	fnClientCrt=${pathCrt}/${cnClient}.crt
	fnClientKey=${pathKey}/${cnClient}.key

	s=$( grep Subject: $fnClientCrt | sed -re "s/.*CN=(.*)\/email.*/\1/" )

	if [[ $s != $cnClient ]]; then

		eval $( udfOnError throw iErrorNotValidArgument "invalid cert file $fnClientCrt" )

	fi

	if [[ -f $fnClientCrt && -f $fnClientKey  && -f $fnServerCrt ]]; then


		udfDebug 3 && printf "client auth info:\n\tremote public key\t- %s\n\tlocal private key\t- %s\n\tlocal Common Name \t- %s\n" "$fnServerCrt" "$fnClientKey" "$cnClient"

	else

		eval $( udfOnError throw iErrorNoSuchFileOrDir "$fnClientCrt and/or $fnClientKey and/or $fnServerCrt" )

	fi

	## TODO send knocks and wait for destination port availibity ( nc -z )
	udfDebug 2 "check server availibity:"
	while true; do

		if echo "${i}%8" | bc | grep '^0$' >/dev/null; then

			knock $host 22025 23501 37565 && echo -n "!"

		fi
		sleep 1

		nc -w 8 -z ${host} ${port} 2>/dev/null && break
		echo -n "."
		i=$((i-1))
		(( $i > 0 )) || eval $( udfOnError throw iErrorNotPermitted "${host}:${port}" )

	done
	udfDebug 2 "ok."
	sleep 4

	udfMakeTemp fnKey
	udfMakeTemp fnPub
	udfMakeTemp fnAns

	## TODO use loop for many times trying
	s="$( wg genkey | tee $fnKey | wg pubkey | tee $fnPub | udfEcho - $cnClient | openssl smime -encrypt -aes256 -outform PEM $fnServerCrt | nc -w 32 -i 8 $host $port | tee $fnAns | openssl smime -decrypt -inform PEM -inkey $fnClientKey | tr -d '\r' )"

	udfDebug 4 && \
		printf "\nclient wirequard keys:\n\tprivate\t- %s\n\tpublic\t- %s\n\n" \
			"$(head -c 10 $fnKey)<skipped>" "$(head -c 10 $fnPub)<skipped>"

	rm -f $fnPub

	if [[ -z "$s" ]]; then

		s="$(< $fnAns)"
		rm -f $fnAns
		eval $( udfOnError throw iErrorNotValidArgument "unexpected answer from ${host}:${port} $s" )

	fi

	[[ $s =~ ^OK: ]] || eval $( udfOnError throw iErrorNotValidArgument "malformed answer from ${host}:${port} $s" )

	a=( ${s//:/ } )

	peer=$( echo ${a[1]} | grep -P "^[a-zA-Z0-9+/]+={0,2}$" )
	udfIsNumber ${a[2]} && port=${a[2]} || port=''
	ipClient=$( udfGetValidIPsOnly ${a[3]} )
	ipServer=$( udfGetValidIPsOnly ${a[4]} )

	udfDebug 3 && \
		printf "server connection properties:\n\tleased ip: %s\n\t   server: %s:%s\n\t     peer: %s\n\n" \
			"$ipClient" "${ipServer}" "${port}" "${peer:0:10}<skipped>"

	udfThrowOnEmptyVariable peer port ipClient ipServer

	udfDebug 4 "Setup network environment for peer ${peer:0:10}<skipped>"
	udfDebug 5 " ${dev}: init device"
	ip link del dev $dev 2>/dev/null || true
	ip link add dev $dev type wireguard

	udfDebug 5 " ${dev}: init peer ${peer:0:10}<skipped> to ${host}:${port} with ip $ipClient"
	wg set $dev private-key $fnKey peer $peer allowed-ips 0.0.0.0/0 persistent-keepalive $keepalive endpoint "${host}:${port}"
	rm -f $fnKey
	ip address add "${ipClient}"/24 dev $dev
	ip link set up dev $dev

	ping -t 1 -c 3 -q $ipServer >/dev/null 2>&1

	eval set -- $(_ sArg)

	if [[ "$1" == "default-route" ]]; then

		host="$(wg show $dev endpoints | sed -n 's/.*\t\(.*\):.*/\1/p')"
		udfDebug 3 "host for route to wg = $host"
		udfDebug 3 "route info for ${host}:"
		ip route get $host
		host="$( ip route get $host | sed '/ via [0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/{s/^\(.* via [0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\).*/\1/}' | head -n 1 )"
		udfDebug 3 "new route $host"
		ip route add $host 2>/dev/null || true
		ip route add 0/1 dev $dev
		ip route add 128/1 dev $dev

	fi

	udfDebug 1 && printf "\nclient configuration done.\n"

	udfDebug 3 && {

		printf "\n\nWireguard interface %s info:\n-----------------------------\n\n" "$dev"

		wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

		ip addr show $dev | grep inet

		printf "\n----\n"

	} >&2

	wg showconf $dev > ${pathIni}/${cnClient}_${cnServer}.${dev}.conf
	chmod 0600 ${pathIni}/${cnClient}_${cnServer}.${dev}.conf

}
#
#
#
udfMain
#
