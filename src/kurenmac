#!/bin/bash
#
# $Id: kurenmac 40 2016-08-27 00:52:02+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
_peIPv4='\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
#
#
#
udfGetValidIPsOnly() {

	[[ -n "$*" ]] || eval $( udfOnError return iErrorEmptyOrMissingArgument )

	local s sDig sOut

	for s in $*; do

		[[ $s =~ ^[0-9.]+$ ]] && ipcalc "$s" | grep '^INVALID ADDRESS:' && continue
		sipcalc -d4 "$s" | grep '^-\[ERR :' && continue
		sDig=$( dig +short $s | xargs )
		[[ -n "$sDig" ]] && s="$sDig"
		sOut+="$s "

	done >/dev/null 2>&1

	echo ${sOut% *} | tr ' ' '\n' | sort | uniq | xargs

	return 0

}
#
udfGetTimeInSec() {

	if [[ "$1" == "-v" ]]; then

		udfIsValidVariable "$2" || eval $( udfOnError2 iErrorNotValidArgument "$2 - variable name required" )

		[[ "$3" == "-v" ]] && eval $( udfOnError2 iErrorNotValidArgument "$3 - number with time suffix expected" )

		eval 'export $2="$( udfGetTimeInSec $3 )"'
		[[ -n ${!2} ]] || eval 'export $2="$( udfGetTimeInSec $4 )"'
		[[ -n ${!2} ]] || eval $( udfOnError2 iErrorEmptyResult "$2 - empty variable" )

		return $?

	fi

	local i=${1%%[[:alpha:]]*}

	udfIsNumber $i || eval $( udfOnError2 iErrorNotValidArgument "$i - number expected" )

	case ${1##*[[:digit:]]} in

		seconds|second|sec|s|'') echo $i;;
		   minutes|minute|min|m) echo $(( i*60 ));;
		        hours|hour|hr|h) echo $(( i*3600 ));;
		             days|day|d) echo $(( i*3600*24 ));;
		           weeks|week|w) echo $(( i*3600*24*7 ));;
		       months|month|mon) echo $(( i*3600*24*30 ));;
		           years|year|y) echo $(( i*3600*24*365 ));;
	                              *) echo ""
                                       eval $( udfOnError2 iErrorNotValidArgument "$1 - number with time suffix expected" )

	esac

    return $?

}
#
udfMain() {

	## TODO set mode (daemon, one time client and etc.)
	## TODO checking tunnel availibity

	[[ $UID == 0 ]] || eval $( udfOnError throw  iErrorNotPermitted "You must be root to run this." )

	local a bDaemonize bDefaultRoute cnClient cnServer dev fn fnAns fnClientCrt fnClientKey fnKey fnPub fnServerCrt host i ini ipClient ipServer pathCrt pathIni pathKey peer port s tsKeepalive

	DEBUGLEVEL=4

	udfThrowOnCommandNotFound  dig echo false grep ip ipcalc knock openssl ping printf route sed sipcalc tee true wg

	pathIni=$( _ pathIni )
	ini=${pathIni}/client.kurenma.ini
	pathCrt=${pathIni}/ssl/public
	pathKey=${pathIni}/ssl/private

	udfIni $ini ':bDaemonize;bDefaultRoute;dev;host;port;tsKeepalive;tsPeerTimeout ssl:cnServer;cnClient'

	: ${dev:=wg0}
	: ${i:=256}
	: ${bDaemonize:=false}

	if udfIsNumber $tsKeepalive; then

		(( $tsKeepalive <= 65355 )) || tsKeepalive=65355

	else

		tsKeepalive=0

	fi

	_bashlyk_sBehaviorOnError=return udfGetTimeInSec -v tsPeerTimeout $tsPeerTimeout "4hours"

	[[ $bDaemonize    =~ ^(false|true)$ ]] || bDaemonize=false
	[[ $bDefaultRoute =~ ^(false|true)$ ]] || bDefaultRoute=false

	udfDebug 2 "configuration:" && udfShowVariable bDaemonize dev host port cnServer cnClient tsKeepalive tsPeerTimeout
	udfThrowOnEmptyVariable cnClient cnServer dev host pathIni port tsPeerTimeout

	fnServerCrt=${pathCrt}/${cnServer}.crt
	fnClientCrt=${pathCrt}/${cnClient}.crt
	fnClientKey=${pathKey}/${cnClient}.key

	s=$( grep Subject: $fnClientCrt | sed -re "s/.*CN=(.*)\/email.*/\1/" )

	if [[ $s != $cnClient ]]; then

		eval $( udfOnError throw iErrorNotValidArgument "invalid cert file $fnClientCrt" )

	fi

	if [[ -f $fnClientCrt && -f $fnClientKey  && -f $fnServerCrt ]]; then

		udfDebug 3 && printf -- "client auth info:\n\tremote public key\t- %s\n\tlocal private key\t- %s\n\tlocal Common Name \t- %s\n" "$fnServerCrt" "$fnClientKey" "$cnClient"

	else

		eval $( udfOnError throw iErrorNoSuchFileOrDir "$fnClientCrt and/or $fnClientKey and/or $fnServerCrt" )

	fi

	udfMakeTemp fnKey
	udfMakeTemp fnPub
	udfMakeTemp fnAns

	while true; do

		s=$( grep keyid $fnServerCrt | sed -r -e "s/^.*keyid:(..):(..):(..):(..):(..):(..):.*$/0x\1\2 0x\3\4 0x\5\6/" )

		[[ -n "$s" ]] || eval $( udfOnError throw "iErrorEmptyOrMissingArgument" "$fnServerCrt - not valid format" )
		udfDebug 5 "server crt keyid head: $s"

		s=$( printf -- "%d %d %d" $s ) || eval $( udfOnError throw "iErrorNotValidArgument" "$fnServerCrt - not valid format" )

		udfDebug 5 "knock  ports sequence: $s"

		udfDebug 2 "check server availibity:"

		while true; do

			if ! (( i % 8 )); then

				knock $host $s
				udfDebug 2 && echo -n "!"

			fi
			sleep 1

			nc -w 3 -z ${host} ${port} 2>/dev/null && break
			udfDebug 2 && echo -n "."
			i=$((i-1))

			if (( $i <= 0 )); then

				eval $( udfOnError warn iErrorNotPermitted "${host}:${port} are unreacheable" )
				i=256
			fi

		done
		udfDebug 2 "ok."
		sleep 4

		s="$( wg genkey | tee $fnKey | wg pubkey | tee $fnPub | udfEcho - $cnClient | openssl smime -encrypt -aes256 -outform PEM $fnServerCrt | nc -w 24 -i 4 $host $port | tee $fnAns | openssl smime -decrypt -inform PEM -inkey $fnClientKey | tr -d '\r' )"

		udfDebug 4 && \
		printf -- "\nclient wirequard keys:\n\tprivate\t- %s\n\tpublic\t- %s\n\n" \
			"$(head -c 10 $fnKey)<skipped>" "$(head -c 10 $fnPub)<skipped>"

		[[ $s =~ ^OK: ]] && break

		[[ -z "$s" ]] && s="$(< $fnAns)"

		eval $( udfOnError warn iErrorNotValidArgument "malformed answer from ${host}:${port} $s" )

		sleep 8

	done

	rm -f $fnPub

	a=( ${s//:/ } )

	peer=$( echo ${a[1]} | grep -P "^[a-zA-Z0-9+/]+={0,2}$" )
	udfIsNumber ${a[2]} && port=${a[2]} || port=''
	ipClient=$( udfGetValidIPsOnly ${a[3]} )
	ipServer=$( udfGetValidIPsOnly ${a[4]} )

	udfDebug 3 && \
		printf -- "server connection properties:\n\tleased ip: %s\n\t   server: %s\n\t     peer: %s\n\t     port: %s\n\n" \
			"$ipClient" "$ipServer" "${peer:0:10}<skipped>" "$port"

	udfThrowOnEmptyVariable peer port ipClient ipServer

	udfDebug 0 && \
		echo -n "Setup tunnel for peer ${peer:0:10}<skipped> with IP $ipClient to ${host}:${port}: "
	#
	try-every-line

		ip link del dev $dev || true
		ip link add dev $dev type wireguard
		wg set $dev private-key $fnKey \
			peer $peer \
			allowed-ips 0.0.0.0/0 \
			persistent-keepalive $tsKeepalive \
			endpoint "${host}:${port}"

		rm -f $fnKey
		ip address add "${ipClient}"/24 dev $dev
		ip link set up dev $dev

	catch-every-line

	if $bDefaultRoute; then

		s="$( wg show $dev endpoints | sed -re 's/.*\t(.*):.*/\1/' )"
		udfDebug 4 "server endpoint: $s"

		s="$( ip route get $s | grep -Po "$_peIPv4 via $_peIPv4" )"
		udfDebug 4 "route rule for server: $s"

		if [[ -n "$s" ]]; then

			try-every-line

				ip route add $s || true
				ip route add 0/1 dev $dev
				ip route add 128/1 dev $dev

			catch-every-line

			udfDebug 2 "tunnel $dev used as default route ($s):" && route -n

		else

			eval $( udfOnError throw iErrorEmptyOrMissingArgument "default route fail" )

		fi

	fi

	udfDebug 1 && printf -- "\nclient configuration done.\n"

	udfDebug 3 && {

		printf -- "\n\nWireGuard interface %s info:\n-----------------------------\n\n" "$dev"

		wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

		ip addr show $dev | grep inet

		printf -- "\n----\n"

	} >&2

	wg showconf $dev > ${pathIni}/${cnClient}_${cnServer}.${dev}.conf
	chmod 0600 ${pathIni}/${cnClient}_${cnServer}.${dev}.conf

	while true; do

		ping -q -W 1 -Ñ 3 $ipServer >/dev/null 2>&1

		$bDaemonize || break

		echo "check connection every $tsPeerTimeout sec.."
		sleep $tsPeerTimeout

		for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

			if udfIsNumber ${s##*:}; then

				if (( $(date +%s) - ${s##*:} >= tsPeerTimeout )); then

					wg set $dev peer ${s%%:*} remove
					udfDebug 4 "peer ${s:0:10}<skipped> removed .. $?"
					exec $0

				fi

			else

				eval $( udfOnError2 warn iErrorNotValidArgument "${s##*:}" )

			fi

		done


	done

}
#
#
#
udfMain
#
