#
# $Id: client.kurenma.src 164 2017-03-09 12:58:05+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
udfKnocking() {

  udfThrowOnEmptyVariable fnCA host portAuth

  local i s

  i=256

  s=$(                                                                         \
                                                                               \
    openssl x509 -sha1 -in $fnCA -noout -fingerprint | sed -r -e               \
    "s/^SHA1 Fing.*nt=(..):(..):(..):(..):(..):(..):.*$/0x\1\2 0x\3\4 0x\5\6/" \
                                                                               \
  )

  [[ $s ]] || eval $(                                                          \
                                                                               \
    udfOnError throw EmptyResult "$fnCA - not valid format"                    \
                                                                               \
  )

  udfDebug 5 "CA cert fingerprint header: $s"

  s=$( printf -- "%d %d %d" $s ) || eval $(                                    \
                                                                               \
    udfOnError throw InvalidArgument "$fnCA - hexadecimal data expected"       \
                                                                               \
  )

  udfDebug 4 "knock ports sequence: $s"

  udfDebug 2 && printf -- "check server %s availibity: " "$host"

  while true; do

    nc -w 3 -z ${host} ${portAuth} 2>/dev/null && break

    ! (( i % 32 )) && echo ""

    udfDebug 2 && echo -n "."

    if ! (( i % 8 )); then

      knock $host $s >/dev/null 2>&1
      udfDebug 2 && echo -n "!"

    fi

    if ! udfWaitSignal 1; then

      echo "x"
      return $(_ iErrorAbortedBySignal)

    fi

    i=$((i-1))

    if (( $i <= 0 )); then

      echo "fail after 256 attempts.. try again"
      eval $( udfOnError warn NotAvailable "${host}:${portAuth}" )
      i=256

    fi

  done >&2

  return 0

}
#
udfGetTunnelSettings() {

  udfThrowOnEmptyVariable cmdSSL cn fnKey host portAuth

  local fmt fnAns pidWatch sKey sPub s

  fmt="\nclient %s keys - public=%s<skip> private=%s<skip>\n"

  s="$(_ iErrorAbortedBySignal) stop signal received"

  udfMakeTemp fnAns

  while true; do

    udfKnocking || break

    udfDebug 2 "ok."

    udfWaitSignal 4 || break

    sKey=$( wg genkey )
    sPub=$( echo $sKey | wg pubkey )
    udfDebug 5 && printf "$fmt" "$cn" "${sPub:0:10}" "${sKey:0:10}"

    udfDebug 1 "server ${host}:${portAuth} - SSL exchange started"

    (                                                                          \
                                                                               \
      udfDebug 5 "watchdog of the SSL exchange started";                       \
      sleep 32;                                                                \
      udfStopProcess $cmdSSL;                                                  \
      udfDebug 5 "watchdog of the SSL exchange completed with status $?"       \
                                                                               \
    ) &
    pidWatch=$!

    s="$(                                                                      \
      echo "client-data $sPub" | $cmdSSL | tr -d '\r' | tee $fnAns             \
        | grep '^OK:'                                                          \
    )"

    udfStopProcess pid=$pidWatch $0 && \
			udfDebug 5 "watchdog of the SSL exchange forced stopped"

    udfDebug 1 "server ${host}:${portAuth} - SSL exchange completed"

    [[ $s =~ ^OK: ]] && break

    [[ $s ]] || s="$(< $fnAns)"

    eval $(                                                                    \
                                                                               \
      udfOnError warn InvalidArgument                                          \
        "malformed answer from ${host}:${portAuth} $s"                         \
                                                                               \
    )

    s="$(_ iErrorAbortedBySignal ) stop signal received"
    udfWaitSignal 8 || break

  done >&2

  rm -f $fnAns

  echo "${s//:/ } $sKey"

  return 0

}
#
udfSetupTunnel() {

  udfThrowOnEmptyVariable dev host aIpsAllowed

  local ipClient ipServer peer port sKey

  [[ $1 == $(_ iErrorAbortedBySignal) ]] && return $(_ iErrorAbortedBySignal)

  [[ $1 != "OK" ]] && return $( _ iErrorInvalidArgument )

  shift

  peer=$( echo $1 | grep -P "^[a-zA-Z0-9+/]+={0,2}$" )
  udfIsNumber $2 && port=$2 || port=''
  ipClient=$( udfGetValidIPsOnly $3 )
  ipServer=$( udfGetValidIPsOnly $4 )
  sKey=$5

  udfDebug 5 && printf "server %s:%s public key - %s<skip>\n" \
                       "$host" "$port" "${peer:0:10}" >&2
  udfDebug 3 && printf "server %s:%s tunnel leased/remote IPs - %s/%s\n" \
                       "$host" "$port" "$ipClient" "$ipServer" >&2

  udfThrowOnEmptyVariable peer port ipClient ipServer

  udfDebug 0 && printf "setup tunnel %s to server %s:%s: " \
                       "$dev" "$host" "$port"

  s="$( udfGetValidCIDR ${aIpsAllowed[@]} )"
  : ${s:=0.0.0.0/0}

  try {

    ip link del dev $dev 2>/dev/null || true
    ip link add dev $dev type wireguard

    wg set $dev private-key <( echo $sKey ) \
      peer $peer \
      allowed-ips ${s// /,} \
      persistent-keepalive $tsKeepalive \
      endpoint "${host}:${port}"

    ## TODO netmask hardcoded
    ip address add "${ipClient}"/24 dev $dev
    ip link set up dev $dev

   } catch {

      ERR::exception.message
      exit $?

   }

  return 0

}
#
udfSetDefaultRoute() {

  udfThrowOnEmptyVariable dev _peIPv4

  local s

  s="$( wg show $dev endpoints | sed -re 's/.*\t(.*):.*/\1/' )"
  udfDebug 4 "server endpoint: $s"

  s="$( ip route get $s | grep -Po "$_peIPv4 via $_peIPv4" )"
  udfDebug 4 "route rule for server: $s"

  if [[ $s ]]; then

  try {

      ip route add $s || true
      ip route add 0/1 dev $dev
      ip route add 128/1 dev $dev

   } catch {

      ERR::exception.message
      exit $?

   }

    udfDebug 2 "tunnel $dev used as default route ($s)"

  else

    eval $( udfOnError throw MissingArgument "default route fail" )

  fi

  return 0

}
#
udfService() {

  udfThrowOnCommandNotFound false knock ping tee true
  udfThrowOnEmptyVariable   bDefaultRoute cn dev host fnCA fnCrt fnKey pathIni \
                            portAuth tsPeerTimeout

  local bStart cmdSSL fmtCon s

  cmdSSL="                                                                     \
    openssl s_client -connect ${host}:${portAuth} -CAfile $fnCA -cert $fnCrt   \
      -key $fnKey -verify 1 -quiet                                             \
  "

  for s in "$fnCrt" "$fnKey" "$fnCA"; do

    [[ -f $s ]] || eval $( udfOnError exitecho NoSuchFileOrDir "$s" )

    if ! grep -P '^-----(BEGIN|END)' $s >/dev/null 2>&1; then

      eval $( udfOnError exitecho InvalidArgument "$s - bad format" )

    fi

  done

  [[ $bDefaultRoute =~ ^(false|true)$ ]] || bDefaultRoute=false

  udfDebug 1 && printf -- "client %s configuration started\n" "$cn"

  bStart=true

  while true; do

    if $bStart; then

      ## TODO try first use saved wg config
      ## TODO bad error handling

      udfSetupTunnel $( udfGetTunnelSettings ) || {

        eval $( udfOnError warn $? "setup tunnel settings" )
        break

      }

      $bDefaultRoute && udfSetDefaultRoute

      udfDebug 1 && printf -- "\nclient %s configuration done.\n" "$cn"

      wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
      chmod 0600 ${pathIni}/${cn}.${dev}.conf

      ping -q -W 1 -с 3 $ipServer >/dev/null 2>&1

    fi

    udfDebug 2 "check connection every $tsPeerTimeout sec.."
    udfWaitSignal $tsPeerTimeout || break

    for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

      if udfIsNumber ${s##*:}; then

        if (( $(date +%s) - ${s##*:} >= tsPeerTimeout )); then

          wg set $dev peer ${s%%:*} remove
          udfDebug 3 "peer ${s:0:10}<skip> removed .. $?"
          bStart=true

        else

          bStart=false

        fi

      else

        eval $( udfOnError warn InvalidArgument "${s##*:}" )

      fi

    done

  done

}
#
#
#
