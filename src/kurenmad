#!/bin/bash
#
# $Id: kurenmad 75 2016-09-15 13:37:17+04:00 toor $"
#
_bashlyk=kurenma . bashlyk
#
#
#
_reIPv4='[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
_bashlyk_iErrorTimeExpired=167
_bashlyk_hError[$_bashlyk_iErrorTimeExpired]="time expired"
_bashlyk_iErrorNotAvailable=166
_bashlyk_hError[$_bashlyk_iErrorNotAvailable]="target is not available"
_bashlyk_iErrorInvalidArgument=253
_bashlyk_hError[$_bashlyk_iErrorInvalidArgument]="invalid argument"
_bashlyk_iErrorInvalidVariable=200
_bashlyk_hError[$_bashlyk_iErrorInvalidVariable]="invalid variable"
_kurenma_pathLib=/usr/share/kurenma
#
#
#
_defLocal() {

	local s S

	for s in ${*//[;,]/ }; do

		udfIsValidVariable $s || eval $( udfOnError throw iErrorNonValidVariable "$s" )
		S+="$s "

	done

	echo "local ${S% *}"

}
#
udfGetValidIPsOnly() {

	udfOn EmptyOrMissingArgument "$*" || return $?

	local s sDig
	local -A h

	for s in $*; do

		[[ $s =~ ^[0-9.]+$ ]] && ipcalc "$s" | grep '^INVALID ADDRESS:' && continue
		sipcalc -d4 "$s" | grep '^-\[ERR :' && continue
		sDig=$( dig +short $s | xargs )
		[[ -n "$sDig" ]] && s="$sDig"
		h[$s]=$s

	done >/dev/null 2>&1

	echo "${h[@]}"

	udfOn EmptyOrMissingArgument return "${h[@]}"

}
#
udfGetValidCIDR() {

	udfThrowOnEmptyVariable _reIPv4
	udfOn EmptyOrMissingArgument "$*" || return $?

	local s i
	local -A h

	for s in $*; do

	[[ $s =~ $_reIPv4 ]] || continue

	i=${s##*/}
	if [[ $s == $i ]]; then

		s=$( udfGetValidIPsOnly $s ) || continue

	else

		udfIsNumber $i && (( i <= 32 )) || continue

		s=$( udfGetValidIPsOnly ${s%/*} ) || continue
		s="${s}/${i}"

	fi

	[[ -n "$s" ]] && h[$s]="$s"

	done

	echo "${h[@]}"

	udfOn EmptyOrMissingArgument return "${h[@]}"

}
#
udfGetTimeInSec() {

	if [[ "$1" == "-v" ]]; then

		udfIsValidVariable "$2" || eval $( udfOnError2 iErrorNotValidArgument "$2 - variable name required" )

		[[ "$3" == "-v" ]] && eval $( udfOnError2 iErrorNotValidArgument "$3 - number with time suffix expected" )

		eval 'export $2="$( udfGetTimeInSec $3 )"'
		[[ -n ${!2} ]] || eval 'export $2="$( udfGetTimeInSec $4 )"'
		[[ -n ${!2} ]] || eval $( udfOnError2 iErrorEmptyResult "$2 - empty variable" )

		return $?

	fi

	local i=${1%%[[:alpha:]]*}

	udfIsNumber $i || eval $( udfOnError2 iErrorNotValidArgument "$i - number expected" )

	case ${1##*[[:digit:]]} in

		seconds|second|sec|s|'') echo $i;;
		   minutes|minute|min|m) echo $(( i*60 ));;
		        hours|hour|hr|h) echo $(( i*3600 ));;
		             days|day|d) echo $(( i*3600*24 ));;
		           weeks|week|w) echo $(( i*3600*24*7 ));;
		       months|month|mon) echo $(( i*3600*24*30 ));;
		           years|year|y) echo $(( i*3600*24*365 ));;
	                              *) echo ""
                                       eval $( udfOnError2 iErrorNotValidArgument "$1 - number with time suffix expected" )

	esac

    return $?

}
#
udfWatchdog() {

	udfOn EmptyOrMissingArgument throw "$1"
	udfIsNumber $2 || eval $( udfOnError2 throw iErrorNonValidArgument "$2" )

	local i=0

	while true; do

		i=$((i+1))

		if [[ -s $1 && $( tail -n 1 $1 ) == "stop" ]]; then

			i=$(_ iErrorAbortedBySignal)
			break

		fi

		sleep 1

		if (( i >= $2 )); then

			i=0
			break

		fi

	done

	return $i
}
#
udfShowPeerInfo() {

	udfThrowOnEmptyVariable dev

	printf -- "\n\nWireGuard interface %s info:\n-----------------------------\n\n" "$dev"

	wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

	ip addr show $dev | grep inet

	printf -- "\n----\n"

}
#
udfMain() {

	DEBUGLEVEL=5

	udfThrowOnCommandNotFound dig echo grep ip ipcalc mkdir nc openssl printf sed sipcalc wg xargs

	[[ $UID == 0 ]] || eval $( udfOnError throw NotPermitted "You must be root to run this." )

	local -a aId
	local fnCtl ini pathCrt pathDat pathIni pathKey pathRun s
	local csvSectionMain csvSectionSSL ipsAllowed aReqOptByRole

	csvSectionMain='bDefaultRoute;dev;host;ipServer;ipClient;port;portAuth;role;tsKeepalive;tsPeerTimeout'
	csvSectionSSL='cnClient;cnServer'
	eval $( _defLocal $csvSectionMain $csvSectionSSL )

	udfExitIfAlreadyStarted

	pathDat=$( _ pathDat )
	pathIni=$( _ pathIni )
	pathRun=$( _ pathRun )

	pathCrt=${pathIni}/ssl/public
	pathKey=${pathIni}/ssl/private
	ini=${pathIni}/kurenma.ini
	fnCtl=${pathRun}/kurenma.pid
	mkdir -p $pathDat || eval $( udfOnError retecho NotExistNotCreated $pathDat )

	udfIni $ini ":${csvSectionMain}" "ssl:${csvSectionSSL}" "ipsAllowed:="

	case $role in

	client)
		aReqOptByRole="cnClient host"
	;;

	server)
		aReqOptByRole="ipServer port"
		: ${ipClient:=dynamic}
		: ${ipServer:=192.168.29.1}
		: ${port:=12912}
	;;

	     *)
		eval $( udfOnError throw NotValidArgument "$role - permissible 'client' or 'server'" )
	;;

	esac

	aId=( $( grep -Po '\044Id\072 \S+ \d+ \S+ \S+ \S+ \044' $0 ) ) && s=", (с) ${aId[3]}, rev${aId[2]}"
	udfDebug 1 "start $( _ s0 ) as ${role}${s}"

	: ${dev:=wg0}
	: ${portAuth:=42912}

	udfIsNumber $tsKeepalive || tsKeepalive=0
	(( $tsKeepalive > 65355 )) && tsKeepalive=65355

	_bashlyk_sBehaviorOnError=return udfGetTimeInSec -v tsPeerTimeout $tsPeerTimeout "32min"

	udfDebug 3 "configuration:" && udfShowVariable cnServer dev ipsAllowed portAuth role tsKeepalive tsPeerTimeout $aReqOptByRole
	udfThrowOnEmptyVariable cnServer dev pathCrt pathDat pathIni pathKey pathRun portAuth role tsPeerTimeout $aRequiredByRole

	[[ -d $_kurenma_pathLib ]] || eval $( udfOnError throw NoSuchFileOrDir "$_kurenma_pathLib" )
	[[ -s ${_kurenma_pathLib}/${role}.kurenma.src ]] || eval $( udfOnError throw NoSuchFileOrDir "${role}.kurenma.src" )

	. ${_kurenma_pathLib}/${role}.kurenma.src

	echo "start" > $fnCtl

	udfService

}
#
#
#
udfMain
#
