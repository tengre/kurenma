#
# $Id: client.kurenma.src 176 2017-12-31 01:58:07+04:00 toor $
#
_bashlyk=kurenma . bashlyk
#
#
#
kurenma-client::knocking() {

  throw on EmptyVariable fnCA host portAuth

  local i s

  i=256

  s=$(                                                                         \
                                                                               \
    openssl x509 -sha1 -in $fnCA -noout -fingerprint | sed -r -e               \
    "s/^SHA1 Fing.*nt=(..):(..):(..):(..):(..):(..):.*$/0x\1\2 0x\3\4 0x\5\6/" \
                                                                               \
  )

  [[ $s ]] || on error throw EmptyResult "$fnCA - not valid format"

  err::debug 5 "CA cert fingerprint header: $s"

  s=$( printf -- "%d %d %d" $s ) || on error throw InvalidArgument "$fnCA - hexadecimal data expected"

  err::debug 4 "knock ports sequence: $s"

  err::debug 2 && printf -- "check server %s availibity: " "$host"

  while true; do

    ping -c 3 ${host} >/dev/null 2>&1 && break

    ! (( i % 32 )) && echo ""

    err::debug 2 && echo -n "."

    if ! (( i % 8 )); then

      knock $host $s >/dev/null 2>&1
      err::debug 2 && echo -n "!"

    fi

    if ! kurenma-daemon::waitSignal 1; then

      echo "x"
      return $( _ iErrorAbortedBySignal )

    fi

    i=$(( i-1 ))

    if (( $i <= 0 )); then

      printf -- "\nfail after 256 attempts.. try again\n"
      on error warn NotAvailable "${host}:${portAuth}"
      i=256

    fi

  done >&2

  return 0

}
#
kurenma-client::getTunnelSettings() {

  throw on EmptyVariable cmdSSL cn fnKey host portAuth

  local fmt fnAns pidWatch sKey sPub s

  fmt="\nclient %s - prepare new session with public key = %s<skip>\n"

  s="$( _ iErrorAbortedBySignal ) stop signal received"

  std::temp fnAns

  while true; do

    kurenma-client::knocking || break

    err::debug 2 "ok."

    kurenma-daemon::waitSignal 4 || break

    sKey=$( exec -c wg genkey )
    sPub=$( echo $sKey | wg pubkey )
    err::debug 5 && printf "$fmt" "$cn" "${sPub:0:10}"

    err::debug 1 "server ${host}:${portAuth} - SSL exchange started"

    (                                                                          \
                                                                               \
      err::debug 5 "watchdog of the SSL exchange started";                     \
      sleep 32;                                                                \
      pid::stop ${cmdSSL//:/ };                                                \
      err::debug 5 "watchdog of the SSL exchange completed with status $?"     \
                                                                               \
    ) &
    pidWatch=$!

    s="$( echo "client-data $sPub" | $cmdSSL | tee $fnAns | grep '^OK:' )"

    pid::stop pid=$pidWatch $0 && \
      err::debug 5 "watchdog of the SSL exchange forced stopped"

    err::debug 1 "server ${host}:${portAuth} - SSL exchange completed"

    [[ $s =~ ^OK: ]] && break

    [[ $s ]] || s="$(< $fnAns)"

    on error warn InvalidArgument "malformed answer from ${host}:${portAuth} $s"

    s="$( _ iErrorAbortedBySignal ) stop signal received"
    kurenma-daemon::waitSignal 8 || break

  done >&2

  rm -f $fnAns

  echo "${s//:/ } $sKey"

  return 0

}
#
kurenma-client::setupTunnel() {

  throw on EmptyVariable dev host aIpsAllowed

  local ipClient ipServer peer port sKey

  [[ $1 == $(_ iErrorAbortedBySignal) ]] && return $(_ iErrorAbortedBySignal)

  [[ $1 != "OK" ]] && return $( _ iErrorInvalidArgument )

  shift

  peer=$( grep -P "^[a-zA-Z0-9+/]+={0,2}$" <<< "$1" )
  std::isNumber $2 && port=$2 || port=''
  ipClient=$( net::ipv4.host $3 )
  ipServer=$( net::ipv4.host $4 )
  sKey=$5

  err::debug 5 && printf "server %s:%s public key - %s<skip>\n" \
                       "$host" "$port" "${peer:0:10}" >&2
  err::debug 3 && printf "server %s:%s tunnel leased/remote IPs - %s/%s\n" \
                       "$host" "$port" "$ipClient" "$ipServer" >&2

  throw on EmptyVariable peer port ipClient ipServer

  err::debug 0 && printf "setup tunnel %s to server %s:%s: " \
                       "$dev" "$host" "$port"

  s="$( net::ipv4.cidr ${aIpsAllowed[@]} )"
  : ${s:=0.0.0.0/0}

  try {

    ip link del dev $dev 2>/dev/null || true
    ip link add dev $dev type wireguard

    wg set $dev private-key <( echo $sKey ) \
      peer $peer \
      allowed-ips ${s// /,} \
      persistent-keepalive $tsKeepalive \
      endpoint "${host}:${port}"

    ## TODO netmask hardcoded
    ip address add "${ipClient}"/24 dev $dev
    ip link set up dev $dev

   } catch {

      err::exception.message
      exit $?

   }

  return 0

}
#
kurenma-client::defaultRoute() {

  throw on EmptyVariable dev _peIPv4

  local s

  s="$( wg show $dev endpoints | sed -re 's/.*\t(.*):.*/\1/' )"
  err::debug 4 "server endpoint: $s"

  s="$( ip route get $s | grep -Po "$_peIPv4 via $_peIPv4" )"
  err::debug 4 "route rule for server: $s"

  if [[ $s ]]; then

  try {

      ip route add $s || true
      ip route add 0/1 dev $dev
      ip route add 128/1 dev $dev

   } catch {

      err::exception.message
      exit $?

   }

    err::debug 2 "tunnel $dev used as default route ($s)"

  else

    on error throw MissingArgument "default route fail"

  fi

  return 0

}
#
# exported function
#
kurenma-daemon::service() {

  throw on CommandNotFound false knock ping tee true
  throw on EmptyVariable   bDefaultRoute cn dev host fnCA fnCrt fnKey pathIni  \
                           protocol portAuth tsPeerTimeout

  local bStart cmdSSL s

  for s in "$fnCrt" "$fnKey" "$fnCA"; do

    [[ -f $s ]] || on error echo+exit NoSuchFileOrDir "$s"

    if ! grep -P '^-----(BEGIN|END)' $s >/dev/null 2>&1; then

      on error echo+exit InvalidArgument "$s - bad format"

    fi

  done

  [[ $bDefaultRoute =~ ^(false|true)$ ]] || bDefaultRoute=false

  cmdSSL="$(                                                                   \
                                                                               \
    printf --                                                                  \
      "openssl s_client -verify 1 -quiet                                       \
       -connect %s:%d                                                          \
       -%s                                                                     \
       -CAfile %s                                                              \
       -cert %s                                                                \
       -key %s                                                                 \
      "                                                                        \
      "${host}" "${portAuth}"                                                  \
      "$protocol"                                                              \
      "$fnCA"                                                                  \
      "$fnCrt"                                                                 \
      "$fnKey"                                                                 \
                                                                               \
  )"

  cmdSSL=$( std::trim $cmdSSL )

  err::debug 6 "openssl command line: $cmdSSL"

  pid::stop openssl s_client.*kurenma

  err::debug 1 && printf -- "client %s configuration started\n" "$cn"

  bStart=true

  while true; do

    if $bStart; then

      ## TODO try first use saved wg config
      ## TODO bad error handling

      kurenma-client::setupTunnel $( kurenma-client::getTunnelSettings ) || {

        on error warn "setup tunnel settings"
        break

      }

      $bDefaultRoute && kurenma-client::defaultRoute

      err::debug 1 && printf -- "\nclient %s configuration done.\n" "$cn"

      wg showconf $dev > ${pathIni}/${cn}.${dev}.conf
      chmod 0600 ${pathIni}/${cn}.${dev}.conf

      ping -q -W 1 -Ñ 3 $ipServer >/dev/null 2>&1

    fi

    err::debug 2 "check connection every $tsPeerTimeout sec.."
    kurenma-daemon::waitSignal $tsPeerTimeout || break

    for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

      if std::isNumber ${s##*:}; then

        if (( $( exec -c date +%s ) - ${s##*:} >= tsPeerTimeout )); then

          wg set $dev peer ${s%%:*} remove
          err::debug 3 "peer ${s:0:10}<skip> removed .. $?"
          bStart=true

        else

          bStart=false

        fi

      else

        on error warn InvalidArgument "${s##*:}"

      fi

    done

  done

}
#
#
#
