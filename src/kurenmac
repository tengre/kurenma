#!/bin/bash
#
# $Id: kurenmac 59 2016-09-09 16:14:18+04:00 toor $
#
_kurenmac_sVersion=0.3
#
_bashlyk=kurenma . bashlyk
#
#
#
_peIPv4='\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
_bashlyk_iErrorTimeExpired=167
_bashlyk_hError[$_bashlyk_iErrorTimeExpired]="time expired"
_bashlyk_iErrorNotAvailable=166
_bashlyk_hError[$_bashlyk_iErrorNotAvailable]="target is not available"
#
#
#
udfWatchdog() {

	udfOn EmptyOrMissingArgument throw "$1"
	udfIsNumber $2 || eval $( udfOnError2 throw iErrorNonValidArgument "$2" )

	local i=0

	while true; do

		i=$((i+1))

		if [[ -s $1 && $( tail -n 1 $1 ) == "stop" ]]; then

			i=$(_ iErrorAbortedBySignal)
			break

		fi

		sleep 1

		if (( i >= $2 )); then

			i=0
			break

		fi

	done

	return $i
}
#
udfGetValidIPsOnly() {

	[[ -n "$*" ]] || eval $( udfOnError return iErrorEmptyOrMissingArgument )

	local s sDig sOut

	for s in $*; do

		[[ $s =~ ^[0-9.]+$ ]] && ipcalc "$s" | grep '^INVALID ADDRESS:' && continue
		sipcalc -d4 "$s" | grep '^-\[ERR :' && continue
		sDig=$( dig +short $s | xargs )
		[[ -n "$sDig" ]] && s="$sDig"
		sOut+="$s "

	done >/dev/null 2>&1

	echo ${sOut% *} | tr ' ' '\n' | sort | uniq | xargs

	[[ -n "${sOut% *}" ]] || eval $( udfOnError return iErrorEmptyResult )

	return 0

}
#
udfGetTimeInSec() {

	if [[ "$1" == "-v" ]]; then

		udfIsValidVariable "$2" || eval $( udfOnError2 iErrorNotValidArgument "$2 - variable name required" )

		[[ "$3" == "-v" ]] && eval $( udfOnError2 iErrorNotValidArgument "$3 - number with time suffix expected" )

		eval 'export $2="$( udfGetTimeInSec $3 )"'
		[[ -n ${!2} ]] || eval 'export $2="$( udfGetTimeInSec $4 )"'
		[[ -n ${!2} ]] || eval $( udfOnError2 iErrorEmptyResult "$2 - empty variable" )

		return $?

	fi

	local i=${1%%[[:alpha:]]*}

	udfIsNumber $i || eval $( udfOnError2 iErrorNotValidArgument "$i - number expected" )

	case ${1##*[[:digit:]]} in

		seconds|second|sec|s|'') echo $i;;
		   minutes|minute|min|m) echo $(( i*60 ));;
		        hours|hour|hr|h) echo $(( i*3600 ));;
		             days|day|d) echo $(( i*3600*24 ));;
		           weeks|week|w) echo $(( i*3600*24*7 ));;
		       months|month|mon) echo $(( i*3600*24*30 ));;
		           years|year|y) echo $(( i*3600*24*365 ));;
	                              *) echo ""
                                       eval $( udfOnError2 iErrorNotValidArgument "$1 - number with time suffix expected" )

	esac

    return $?

}
#
_defLocal() {

	local s S

	for s in ${*//[;,]/ }; do

		udfIsValidVariable $s || eval $( udfOnError throw iErrorNonValidVariable "$s" )
		S+="$s "

	done

	echo "local ${S% *}"

}
#
udfKnocking() {

	udfThrowOnEmptyVariable fnCtl fnServerCrt host portAuth

	local i s

	i=256

	s=$( grep keyid $fnServerCrt | sed -r -e "s/^.*keyid:(..):(..):(..):(..):(..):(..):.*$/0x\1\2 0x\3\4 0x\5\6/" )

	[[ -n "$s" ]] || eval $( udfOnError2 throw "EmptyResult" "$fnServerCrt - not valid format" )

	udfDebug 5 "server crt keyid head: $s"

	s=$( printf -- "%d %d %d" $s ) || eval $( udfOnError2 throw "NotValidArgument" "$fnServerCrt - hexadecimal data expected" )

	udfDebug 5 "knock  ports sequence: $s"

	udfDebug 2 "check server $host availibity:"

	while true; do

		if ! (( i % 8 )); then

			knock $host $s
			udfDebug 2 && echo -n "!"

		fi

		if ! udfWatchdog $fnCtl 1; then

			echo "x"
			return $(_ iErrorAbortedBySignal)

		fi

		nc -w 3 -z ${host} ${portAuth} 2>/dev/null && break
		udfDebug 2 && echo -n "."

		i=$((i-1))

		! (( i % 32 )) && echo ""

		if (( $i <= 0 )); then

			echo "fail after 256 attempts.. try again"
			eval $( udfOnError2 warn NotAvailable "${host}:${portAuth}" )
			i=256

		fi

	done >&2

	return 0

}
#
udfGetTunnelSettings() {

	udfThrowOnEmptyVariable cnClient fnCtl fnClientKey host portAuth

	local fnPub fnAns sKey s

	s="$(_ iErrorAbortedBySignal) stop signal received"

	udfMakeTemp fnPub
	udfMakeTemp fnAns

	while true; do

		udfKnocking || break

		udfDebug 2 "ok."

		udfWatchdog $fnCtl 4 || break

		sKey=$( wg genkey )

		s="$( echo $sKey | wg pubkey | tee $fnPub | udfEcho - $cnClient | openssl smime -encrypt -aes256 -outform PEM $fnServerCrt | nc -w 24 -i 4 $host $portAuth | tee $fnAns | openssl smime -decrypt -inform PEM -inkey $fnClientKey | tr -d '\r' )"

		udfDebug 3 && \
		printf -- "\nclient WireGuard keys:\nprivate - %s\npublic  - %s\n" \
			"${sKey:0:10}<skipped>" "$(head -c 10 $fnPub)<skipped>"

		[[ $s =~ ^OK: ]] && break

		[[ -z "$s" ]] && s="$(< $fnAns)"

		eval $( udfOnError2 warn iErrorNotValidArgument "malformed answer from ${host}:${portAuth} $s" )

		s="$(_ iErrorAbortedBySignal ) stop signal received"
		udfWatchdog $fnCtl 8 || break

	done >&2

	rm -f $fnAns $fnPub

	echo "${s//:/ } $sKey"

	return 0
}
#
udfSetupTunnel() {

	udfThrowOnEmptyVariable dev host

	local ipClient ipServer peer port sKey

	[[ $1 == $( _ iErrorAbortedBySignal  ) ]] && return $( _ iErrorAbortedBySignal  )
	[[ $1 != "OK"   ]] && return $( _ iErrorNonValidArgument )

	shift

	peer=$( echo $1 | grep -P "^[a-zA-Z0-9+/]+={0,2}$" )
	udfIsNumber $2 && port=$2 || port=''
	ipClient=$( udfGetValidIPsOnly $3 )
	ipServer=$( udfGetValidIPsOnly $4 )
	sKey=$5

	udfDebug 3 && printf -- "$fmtCon" "$host" "$port" "${peer:0:10}<skipped>" "$ipClient" "$ipServer"

	udfThrowOnEmptyVariable peer port ipClient ipServer

	udfDebug 0 && printf -- "Setup tunnel for peer %s<skipped>: " "${peer:0:10}"
	#
	try-every-line

		ip link del dev $dev || true
		ip link add dev $dev type wireguard

		wg set $dev private-key <( echo $sKey ) \
			peer $peer \
			allowed-ips 0.0.0.0/0 \
			persistent-keepalive $tsKeepalive \
			endpoint "${host}:${port}"

		ip address add "${ipClient}"/24 dev $dev
		ip link set up dev $dev

	catch-every-line

	return 0

}
#
udfSetDefaultRoute() {

	udfThrowOnEmptyVariable dev _peIPv4

	local s

	s="$( wg show $dev endpoints | sed -re 's/.*\t(.*):.*/\1/' )"
	udfDebug 4 "server endpoint: $s"

	s="$( ip route get $s | grep -Po "$_peIPv4 via $_peIPv4" )"
	udfDebug 4 "route rule for server: $s"

	if [[ -n "$s" ]]; then

		try-every-line

			ip route add $s || true
			ip route add 0/1 dev $dev
			ip route add 128/1 dev $dev

		catch-every-line

		udfDebug 2 "tunnel $dev used as default route ($s):" && route -n

	else

		eval $( udfOnError throw iErrorEmptyOrMissingArgument "default route fail" )

	fi

	return 0

}
#
udfShowPeerInfo() {

	udfThrowOnEmptyVariable dev

	printf -- "\n\nWireGuard interface %s info:\n-----------------------------\n\n" "$dev"

	wg show $dev | sed -re "s/(peer:|public.?key[ :]|private.?key[ :]).*$/\1 <hidden>/ig"

	ip addr show $dev | grep inet

	printf -- "\n----\n"

}
#
udfMain() {

	## TODO set mode (daemon, one time client and etc.)
	## TODO checking tunnel availibity

	DEBUGLEVEL=3

	udfThrowOnCommandNotFound dig echo false grep ip ipcalc knock openssl ping printf route sed sipcalc tee true wg xargs

	[[ $UID == 0 ]] || eval $( udfOnError throw NotPermitted "You must be root to run this." )

	local -a aId
	local bStart fnClientCrt fmtCon fmtSSL fnClientKey fnCtl fnServerCrt ini pathCrt pathIni pathKey pathRun s sKey
	local csvSectionMain csvSectionSSL ipsAllowed

	#
	aId=( $( grep -Po '\044Id\072 \S+ \d+ \S+ \S+ \S+ \044' $0 ) ) && udfDebug 1 "start $( _ s0 ) (с) ${aId[3]}, rev${aId[2]}"
	#
	fmtSSL="SSL auth info:\nClient Common Name - %s\nServer Common Name - %s\n"
	fmtCon="Connection properties from %s:\nremote port: %d\nserver  key: %s\ntunnel  IPs: leased/remote - %s/%s\n"
	csvSectionMain='bDaemonize;bDefaultRoute;dev;host;ipServer;ipClient;port;portAuth;role;tsKeepalive;tsPeerTimeout'
	csvSectionSSL='cnClient;cnServer'
	eval $( _defLocal $csvSectionMain $csvSectionSSL )

	pathRun=$( _ pathRun )
	fnCtl=${pathRun}/kurenma.pid
	pathIni=$( _ pathIni )
	ini=${pathIni}/kurenma.ini
	pathCrt=${pathIni}/ssl/public
	pathKey=${pathIni}/ssl/private

	udfIni $ini ":${csvSectionMain}" "ssl:${csvSectionSSL}"

	: ${bDaemonize:=false}
	: ${dev:=wg0}
	: ${i:=256}
	: ${portAuth:=42912}

	udfIsNumber $tsKeepalive || tsKeepalive=0
	(( $tsKeepalive > 65355 )) && tsKeepalive=65355

	_bashlyk_sBehaviorOnError=return udfGetTimeInSec -v tsPeerTimeout $tsPeerTimeout "32min"

	[[ $bDaemonize    =~ ^(false|true)$ ]] || bDaemonize=false
	[[ $bDefaultRoute =~ ^(false|true)$ ]] || bDefaultRoute=false

	udfDebug 4 "configuration:" && udfShowVariable bDaemonize cnServer cnClient dev host portAuth tsKeepalive tsPeerTimeout
	udfThrowOnEmptyVariable cnClient cnServer dev host pathCrt pathKey pathIni pathRun portAuth tsPeerTimeout

	fnServerCrt=${pathCrt}/${cnServer}.crt
	fnClientCrt=${pathCrt}/${cnClient}.crt
	fnClientKey=${pathKey}/${cnClient}.key

	s=$( grep Subject: $fnClientCrt | sed -re "s/.*CN=(.*)\/email.*/\1/" )

	if [[ $s != $cnClient ]]; then

		eval $( udfOnError throw iErrorNotValidArgument "invalid cert file $fnClientCrt" )

	fi

	if [[ -f $fnClientCrt && -f $fnClientKey  && -f $fnServerCrt ]]; then

		udfDebug 3 && printf -- "$fmtSSL" "$cnClient" "$cnServer"

	else

		eval $( udfOnError throw iErrorNoSuchFileOrDir "$fnClientCrt and/or $fnClientKey and/or $fnServerCrt" )

	fi

	udfExitIfAlreadyStarted

	echo start > $fnCtl

	bStart=true

	while true; do

		if $bStart; then

			## TODO try first use saved wg config

			udfSetupTunnel $( udfGetTunnelSettings ) || {

				eval $( udfOnError2 warn $? "setup tunnel settings" )
				break
			}

			$bDefaultRoute && udfSetDefaultRoute
			udfDebug 1 && printf -- "\nclient configuration done.\n"
			udfDebug 5 && udfShowPeerInfo

			wg showconf $dev > ${pathIni}/${cnClient}_${cnServer}.${dev}.conf
			chmod 0600 ${pathIni}/${cnClient}_${cnServer}.${dev}.conf

			ping -q -W 1 -с 3 $ipServer >/dev/null 2>&1
			$bDaemonize || break

		fi

		udfDebug 2 "check connection every $tsPeerTimeout sec.."
		## TODO force check with async message
		udfWatchdog $fnCtl $tsPeerTimeout || break

		for s in $( wg show $dev latest-handshakes | tr '\t' ':' | xargs ); do

			if udfIsNumber ${s##*:}; then

				if (( $(date +%s) - ${s##*:} >= tsPeerTimeout )); then

					wg set $dev peer ${s%%:*} remove
					udfDebug 3 "peer ${s:0:10}<skipped> removed .. $?"
					bStart=true

				else

					bStart=false

				fi

			else

				eval $( udfOnError2 warn iErrorNotValidArgument "${s##*:}" )

			fi

		done

	done

	udfFinally "service down after"

}
#
#
#
udfMain
#
