#!/bin/bash
#
# $Id: kurenmad 194 2018-01-21 13:42:25+04:00 toor $"
#
_bashlyk=kurenma . bashlyk
#
#
#
_kurenma_pathLib=/usr/share/kurenma
_kurenma_sSignal=none
#
#
#
#****h* kurenma/.
#
#  DESCRIPTION
#
#    kurenma  is a package that includes tools for configuration and control
#    WireGuard tunnels.
#
#  COMMANDS
#
#    kurenmactl
#        management tool for kurenmad(8) daemon
#
#    kurenmad
#        daemon for automatic configuration and control of the WireGuard tunnels
#
#    gen-ssl-kurenma
#        generate   CA   infrastructure   based   on   OpenSSL   and   x.509
#        certificate/key pair for client and server peers
#
#    setup-knockd
#        get   knock-sequence   of   port   numbers   from   the    server's
#        X.509-certificate and write the appropriate section of the settings
#        in the knockd.conf(5) configuration file. Only required for  server
#        roles
#
#    update-firehol
#        adds  the  IP-address to the white list of the firehol(1) firewall.
#        It's designed to run from the service knockd(1) to allow  WireGuard
#        client access
#
#  SEE ALSO
#       kurenmactl(8), kurenmad(8), kurenma.ini(5), gen-ssl-kurenma(8),
#       update-firehol(8), setup-knockd(8), firehol(1), knockd(1),
#       knockd.conf(5)
#******
#****h* kurenma/command
#  DESCRIPTION
#
#    This section described commands of package
#
#******
#****h* kurenma/configuration
#  DESCRIPTION
#
#    This section described configurations of package
#
#******
#****h* command/kurenmad
#
#  USAGE
#
#    kurenmad
#
#  DESCRIPTION
#
#    kurenmad - daemon for automatic configuration and control of the WireGuard
#    tunnels.
#    Depending on the role, kurenmad acts as a server that receives requests
#    to  create  WireGuard  tunnel or as a client requesting the creation of
#    such a tunnel. For key exchanging used X.509 certificates.
#
#  SEE ALSO
#
#    kurenma(7), kurenmactl(8), kurenma.ini(5)
#
#******
kurenma-daemon::waitSignal() {

  if [[ $_kurenma_sSignal == "stop" ]]; then

    err::debug 4 "Stop signal received before waiting"
    return $( _ iErrorAbortedBySignal )

  fi

  std::isDecimal $1 || on error return NotDecimal "${1:-first argument}"

  sleep ${1//-/} &
  wait $!

  if [[ $_kurenma_sSignal == "stop" ]]; then

    err::debug 4 "Stop signal is received while waiting"
    return $( _ iErrorAbortedBySignal )

  fi

  return 0

}
#
kurenma-daemon::signal() {

  [[ $_kurenma_control_channel && -p $_kurenma_control_channel ]] \
    && echo "signalStop" > $_kurenma_control_channel

  _kurenma_sSignal='stop'

  pid::stop childs sleep

  std::finally "service down initiated by signal,"

  sleep 1.8

}
#
kurenma-daemon::main() {

  DEBUGLEVEL=5

  [[ $UID == 0 ]] || on error warn+exit NotPermitted "You must be root to run this."

  pid::onStarted.exit

  exit+warn on CommandNotFound grep ip mkdir nc openssl ping sed sleep tail wg

  local -a aId aIpsAllowed
  local ini fnCA fnCrt fnKey pathCA pathCrt pathDat pathIni pathKey pathRun s
  local bDefaultRoute pool port portAuth role tsKeepalive tsPeerTimeout
  local aReqOptByRole ca cn dh dev host server protocol tsPeerInactivity
  local -r reProtocol='^((no)?ssl[23]|(no)?tls(1|1_1|1_2)|dtls1(_2)?|auto)$'


  pathDat=$( _ pathDat )
  pathIni=$( _ pathIni )
  pathRun=$( _ pathRun )

  pathCA=${pathIni}/ssl/certs
  pathCrt=${pathIni}/ssl/public
  pathKey=${pathIni}/ssl/private
  ini=${pathIni}/kurenma.ini

  mkdir -p $pathDat || on error echo+return NotExistNotCreated $pathDat

  INI ini
  ini.load $ini                                                                \
               []role,tunnel name,server,listen port,tunnel network,           \
                 IP lease method,persistent keepalive,pause between checks,    \
                 default route                                                 \
                                                                               \
            [ssl]ca,cn,dh,port,protocol                                        \
                                                                               \
    [ips allowed]=

  s=$( ini.get [ips allowed] )
  eval "${s/declare -a a/declare -a aIpsAllowed}"

  role=$( ini.get role )

  case $role in

  client)

             host=$( ini.get server )
    bDefaultRoute=$( ini.get default route )

    : ${bDefaultRoute:=false}
    [[ ${aIpsAllowed[@]} ]] || aIpsAllowed[0]='0.0.0.0/0'

    _bashlyk_OnError=return tsPeerTimeout=$(                                   \
      std::getTimeInSec $( ini.get pause between checks ) "3min"               \
    )

    if (( tsPeerTimeout < 60 )); then

      on error warn InvalidArgument "$tsPeerTimeout is too low, it increased to 60"
      tsPeerTimeout=60

    fi

    aReqOptByRole="host"

  ;;

  server)

      pool=$( ini.get IP lease method )
      port=$( ini.get listen port )
    server=$( net::ipv4.cidr $( ini.get tunnel network ) )

    :   ${pool:=dynamic}
    :   ${port:=12912}
    : ${server:=192.168.29.1/24}

    _bashlyk_OnError=return tsPeerTimeout=$(                                   \
      std::getTimeInSec $( ini.get pause between checks ) "0"                  \
    )

    aReqOptByRole="server pool port"

  ;;

      *)

    on error throw InvalidArgument "$role - must have client or server"

  ;;

  esac

  cn=$( ini.get [ssl]cn )

  if [[ -s ${_kurenma_pathLib}/VERSION ]]; then

    a=( $( < ${_kurenma_pathLib}/VERSION ) )

    s="$(                                                                      \
         printf -- ", %s.%s %s, (c) 2016-%s\n\n"                               \
                   "${a[0]}" "${a[1]}" "${a[2]}" "$( exec -c date +%Y )"       \
      )"

  elif a=($( exec -c grep -Po '\044Id\072 \S+ \d+ \S+ \S+ \S+ \044' $0 )); then

    s="$(                                                                      \
          printf -- ", %s.%s %s, (c) 2016-%s\n\n"                              \
                    "${a[2]}" "${a[3]}" "$( exec -c date +%Y )"                \
      )"

  else

    s=

  fi

  err::debug 1 "start ${0##*/} as ${role}${s}"

       dev=$( ini.get tunnel name   )
  portAuth=$( ini.get [ssl]port     )
  protocol=$( ini.get [ssl]protocol )

  :      ${dev:=wg0}
  : ${portAuth:=42912}
  : ${protocol:=auto}

  if [[ $protocol !=~ $reProtocol ]]; then

    on error warn InvalidArgument "protocol \"$protocol\" is bad, used default"
    protocol='auto'

  fi

  tsKeepalive=$( ini.get persistent keepalive )
  std::isNumber $tsKeepalive || tsKeepalive=0
  (( tsKeepalive > 65355 )) && tsKeepalive=65355

  if err::debug 3; then

    printf -- "configuration:\n~~~~~~~~~~~~~~\n"
    ini.show | sed -re "s/^[[:space:]]/\xc2\xa0/"
    printf -- "~~~~~~~~~~~~~~\n"

  fi

  [[ $protocol =~ ^auto$ ]] && protocol='' || protocol="-${protocol}"

  throw on EmptyVariable cn dev pathCrt pathDat pathIni pathKey pathRun        \
                         portAuth role tsPeerTimeout $aReqOptByRole

  fnCA=${pathCrt}/cacert.pem
  fnCrt=${pathCrt}/${cn}.crt
  fnKey=${pathKey}/${cn}.key

  [[ -d $_kurenma_pathLib ]] || on error throw NoSuchFileOrDir $_kurenma_pathLib

  [[ -s ${_kurenma_pathLib}/${role}.kurenma.src ]] || on error throw NoSuchFileOrDir "${role}.kurenma.src"

  . ${_kurenma_pathLib}/${role}.kurenma.src

  trap kurenma-daemon::signal 31

  kurenma-daemon::service

  std::finally "service down,"

}
#
#
#
kurenma-daemon::main
#
